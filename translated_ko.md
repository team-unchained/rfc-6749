# The OAuth 2.0 Authorization Framework

### 초록 (Abstract)

OAuth 2.0 인증 프레임워크는 서드파티 애플리케이션이 HTTP 서비스에 제한적인 접근 권한을 얻을 수 있도록 합니다. 이는 리소스 소유자(Resource Owner)를 대신하여 리소스 소유자와 HTTP 서비스 간의 승인 절차를 조정함으로써 이루어질 수도 있으며, 또는 서드파티 애플리케이션이 독자적으로 접근 권한을 획득할 수도 있습니다. 본 사양은 RFC 5849에서 정의된 OAuth 1.0 프로토콜을 대체하며, 이를 폐기합니다.

### 이 문서의 상태 (Status of This Memo)

이 문서는 인터넷 표준 트랙(Internet Standards Track) 문서입니다.

본 문서는 **인터넷 엔지니어링 태스크 포스(IETF)** 의 산출물로, IETF 커뮤니티의 합의를 반영하고 있습니다. 또한, 공공 검토를 거쳤으며, **인터넷 엔지니어링 지도 그룹(IESG)** 에 의해 공식적으로 출판이 승인되었습니다. 인터넷 표준에 대한 추가 정보는 RFC 5741의 2장에서 확인할 수 있습니다.

이 문서의 현재 상태, 정정(errata) 사항, 그리고 피드백 제공 방법에 대한 정보는 다음 링크에서 확인할 수 있습니다:
🔗 <http://www.rfc-editor.org/info/rfc6749>

### 저작권 공지 (Copyright Notice)

이 문서의 저작권은 2012년 IETF Trust 및 문서의 저자로 명시된 개인들에게 있습니다. 모든 권리는 보호됩니다.

이 문서는 BCP 78 및 IETF Trust의 법적 조항(🔗 <http://trustee.ietf.org/license-info)의> 적용을 받으며, 해당 문서가 출판된 날짜의 기준으로 효력이 발생합니다. 사용자는 위의 법적 조항을 신중히 검토해야 하며, 이는 본 문서의 사용 및 제한 사항을 설명하고 있습니다.

이 문서에서 추출된 코드 컴포넌트(Code Components)는 **간소화된 BSD 라이선스(Simplified BSD License)** 에 명시된 라이선스 조항을 포함해야 합니다. 해당 라이선스 조항은 Trust Legal Provisions의 4.e 항목에 설명되어 있으며, 제공되는 코드에는 보증이 적용되지 않습니다.

## 목차

**1. [소개](#1-소개)**

- [1.1. 역할](#11-역할)
  - [1.2. 프로토콜 흐름](#12-프로토콜-흐름)
  - [1.3. 인가 승인](#13-인가-승인)
    - [1.3.1. 인가 코드](#131-인가-코드)
    - [1.3.2. 암묵적 승인](#132-암묵적-승인)
    - [1.3.3. 리소스 소유자 비밀번호 자격 증명](#133-리소스-소유자-비밀번호-자격-증명)
    - [1.3.4. 클라이언트 자격 증명](#134-클라이언트-자격-증명)
  - [1.4. 액세스 토큰](#14-액세스-토큰)
  - [1.5. 리프레시 토큰](#15-리프레시-토큰)
  - [1.6. TLS 버전](#16-tls-버전)
  - [1.7. HTTP 리디렉션](#17-http-리디렉션)
  - [1.8. 상호 운용성](#18-상호-운용성)
  - [1.9. 표기 규칙](#19-표기-규칙)

**2. [클라이언트 등록](#2-클라이언트-등록)**

- [2.1. 클라이언트 유형](#21-클라이언트-유형)
- [2.2. 클라이언트 식별자](#22-클라이언트-식별자)
- [2.3. 클라이언트 인증](#23-클라이언트-인증)
  - [2.3.1. 클라이언트 비밀번호](#231-클라이언트-비밀번호)
  - [2.3.2. 기타 인증 방법](#232-기타-인증-방법)
- [2.4. 미등록 클라이언트](#24-미등록-클라이언트)

**3. [프로토콜 엔드포인트](#3-프로토콜-엔드포인트)**

- [3.1. 인가 엔드포인트](#31-인가-엔드포인트)
  - [3.1.1. 응답 유형](#311-응답-유형)
  - [3.1.2. 리디렉션 엔드포인트](#312-리디렉션-엔드포인트)
- [3.2. 토큰 엔드포인트](#32-토큰-엔드포인트)
  - [3.2.1. 클라이언트 인가](#321-클라이언트-인증)
- [3.3. 액세스 토큰 범위](#33-액세스-토큰-범위)

**4. [인가 승인 받기](#4-인가-승인-받기)**

- [4.1. 인가 코드 승인](#41-인가-코드-승인)
  - [4.1.1. 인가 요청](#411-인가-요청)
  - [4.1.2. 인가 응답](#412-인가-응답)
  - [4.1.3. 액세스 토큰 요청](#413-액세스-토큰-요청)
  - [4.1.4. 액세스 토큰 응답](#414-액세스-토큰-응답)
- [4.2. 암묵적 승인](#42-암묵적-승인)
  - [4.2.1. 인가 요청](#421-인가-요청)
  - [4.2.2. 액세스 토큰 응답](#422-액세스-토큰-응답)
- [4.3. 리소스 소유자 비밀번호 자격 증명 승인 방식](#43-리소스-소유자-비밀번호-자격-증명-승인-방식)
  - [4.3.1. 인가 요청 및 응답](#431-인가-요청-및-응답)
  - [4.3.2. 액세스 토큰 요청](#432-액세스-토큰-요청)
  - [4.3.3. 액세스 토큰 응답](#433-액세스-토큰-응답)
- [4.4. 클라이언트 자격 증명 승인 방식](#44-클라이언트-자격-증명-승인-방식)
  - [4.4.1. 인가 요청 및 응답](#441-인가-요청-및-응답)
  - [4.4.2. 액세스 토큰 요청](#442-액세스-토큰-요청)
  - [4.4.3. 액세스 토큰 응답](#443-액세스-토큰-응답)
- [4.5. 확장 승인](#45-확장-승인)

**5. [액세스 토큰 발급](#5-액세스-토큰-발급)**

- [5.1. 성공 응답](#51-성공-응답)
- [5.2. 오류 응답](#52-오류-응답)

**6. [액세스 토큰 갱신](#6-액세스-토큰-갱신)**

**7. [보호된 리소스 접근](#7-보호된-리소스-접근)**

- [7.1. 액세스 토큰 유형](#71-액세스-토큰-유형)
- [7.2. 오류 응답](#72-오류-응답)

**8. [확장성](#8-확장성)**

- [8.1. 액세스 토큰 유형 정의](#81-액세스-토큰-유형-정의)
- [8.2. 새로운 엔드포인트 매개변수 정의](#82-새로운-엔드포인트-매개변수-정의)
- [8.3. 새로운 인가 승인 유형 정의](#83-새로운-인가-승인-유형-정의)
- [8.4. 새로운 인가 엔드포인트 응답 유형 정의](#84-새로운-인가-엔드포인트-응답-유형-정의)
- [8.5. 추가 오류 코드 정의](#85-추가-오류-코드-정의)

**9. [네이티브 애플리케이션](#9-네이티브-애플리케이션)**

**10. [보안 고려 사항](#10-보안-고려-사항)**

- [10.1. 클라이언트 인증](#101-클라이언트-인증)
- [10.2. 클라이언트 사칭](#102-클라이언트-사칭)
- [10.3. 액세스 토큰](#103-액세스-토큰)
- [10.4. 리프레시 토큰](#104-리프레시-토큰)
- [10.5. 인가 코드](#105-인가-코드)
- [10.6. 인가 코드 리디렉션 URI 조작](#106-인가-코드-리디렉션-uri-조작)
- [10.7. 리소스 소유자 비밀번호 자격 증명](#107-리소스-소유자-비밀번호-자격-증명)
- [10.8. 요청 기밀성 유지](#108-요청-기밀성-유지)
- [10.9. 엔드포인트의 신뢰성 확보](#109-엔드포인트의-신뢰성-확보)
- [10.10. 자격 증명 추측 공격](#1010-자격-증명-추측-공격)
- [10.11. 피싱 공격](#1011-피싱-공격)
- [10.12. 크로스 사이트 요청 위조 (CSRF)](#1012-크로스-사이트-요청-위조-csrf)
- [10.13. 클릭재킹](#1013-클릭재킹)
- [10.14. 코드 삽입 및 입력 검증](#1014-코드-삽입-및-입력-검증)
- [10.15. 오픈 리디렉터](#1015-오픈-리디렉터)
- [10.16. 암묵적 승인 흐름에서 액세스 토큰 오용](#1016-암묵적-승인-흐름에서-액세스-토큰-오용)

**11. [IANA 고려 사항](#11-IANA-고려-사항)**

- [11.1. OAuth 액세스 토큰 유형 등록](#111-oauth-액세스-토큰-유형-등록)
  - [11.1.1. 등록 템플릿](#1111-등록-템플릿)
- [11.2. OAuth 매개변수 등록](#112-oauth-매개변수-등록)
  - [11.2.1. 등록 템플릿](#1121-등록-템플릿)
  - [11.2.2. 초기 등록 내용](#1122-초기-등록-내용)
- [11.3. OAuth 인가 엔드포인트 응답 유형 등록](#113-oauth-인가-엔드포인트-응답-유형-등록)
  - [11.3.1. 등록 템플릿](#1131-등록-템플릿)
  - [11.3.2. 초기 등록 내용](#1132-초기-등록-내용)
- [11.4. OAuth 확장 오류 등록](#114-oauth-확장-오류-등록)
  - [11.4.1. 등록 템플릿](#1141-등록-템플릿)

**12. [참고 문헌](#12-참고-문헌)**

- [12.1. 규범적 참고 문헌](#121-규범적-참고-문헌)
- [12.2. 정보성 참고 문헌](#122-정보성-참고-문헌)

## 1. 소개

전통적인 클라이언트-서버 인증 모델에서는 클라이언트(Client)가 서버에서 접근 제한된 리소스(보호된 리소스)에 접근하려고 할 때, 리소스 소유자의 자격 증명을 사용하여 서버에 인증을 수행합니다.

그러나 제삼자 애플리케이션이 이러한 제한된 리소스에 접근할 수 있도록 하기 위해서는, 리소스 소유자(resource owner)가 자신의 자격 증명을 제삼자와 공유해야 합니다.

이 방식은 여러 가지 문제와 제한점을 초래합니다.

- 제삼자 애플리케이션은 리소스 소유자의 자격 증명을 향후 사용을 위해 저장해야 하며, 일반적으로는 비밀번호를 평문(암호화되지 않은 형태)으로 저장해야 합니다.
- 서버는 비밀번호에 내재된 보안 취약점에도 불구하고 비밀번호 인증을 지원해야 합니다.
- 제삼자 애플리케이션은 리소스 소유자의 보호된 리소스에 과도하게 넓은 접근 권한을 얻으며, 그로 인해 리소스 소유자는 특정 리소스의 접근 범위나 기간을 제한할 수 없게 됩니다.
- 리소스 소유자는 특정 제삼자만 선택적으로 접근을 차단할 수 없다. 만약 특정 제삼자의 접근을 차단하려면, 모든 제삼자의 접근을 함께 차단해야 한다. 그리고 이를 수행하려면 제삼자의 비밀번호를 변경해야 합니다.
- 어떤 제삼자 애플리케이션이 해킹당하면, 최종 사용자의 비밀번호와 그 비밀번호로 보호되는 모든 데이터도 함께 유출될 수 있습니다.

OAuth는 인가 계층을 도입하고, 클라이언트의 역할을 리소스 소유자의 역할과 분리함으로써 이러한 문제를 해결합니다.
OAuth에서는 클라이언트가 리소스 소유자가 관리하고 리소스 서버가 호스팅하는 리소스에 대한 접근을 요청하며, 리소스 소유자의 자격 증명과는 다른 새로운 자격 증명을 발급받습니다.

클라이언트는 보호된 리소스에 접근하기 위해 리소스 소유자의 자격 증명을 직접 사용하는 대신, 특정 범위, 유효 기간 및 기타 접근 속성을 나타내는 문자열인 액세스 토큰을 발급 받습니다.
이 액세스 토큰은 리소스 소유자의 승인 하에 인가 서버를 통해 제삼자 클라이언트에게 발급됩니다.
이후 클라이언트는 액세스 토큰을 사용하여 리소스 서버가 호스팅하는 보호된 리소스에 접근합니다.

예를 들어, 최종 사용자는 사진 공유 서비스(리소스 서버)에 저장된 자신의 보호된 사진에 대한 접근 권한을 인쇄 서비스(클라이언트)에게 부여할 수 있습니다.
이 과정에서 사용자는 인쇄 서비스에 자신의 사용자 이름과 비밀번호를 공유할 필요가 없습니다.
대신, 사용자는 사진 공유 서비스가 신뢰하는 서버(인가 서버)에서 직접 인증을 수행하며, 이 서버는 인쇄 서비스에게 특정 권한을 위한 자격 증명(액세스 토큰)을 발급합니다.

사양은 HTTP([RFC2616](https://datatracker.ietf.org/doc/html/rfc2616))에서 사용하도록 설계되었습니다.
HTTP 이외의 프로토콜에서 OAuth를 사용하는 것은 이 사양의 범위를 벗어납니다.

OAuth 1.0 프로토콜([RFC5849](https://datatracker.ietf.org/doc/html/rfc5849))은 정보 제공 문서로 발행되었으며, 소규모의 비공식적인 커뮤니티 활동의 결과물이었습니다.
이 표준화 사양은 OAuth 1.0의 배포 경험을 바탕으로 구축되었으며, IETF 커뮤니티에서 수집한 추가적인 사용 사례와 확장성 요구 사항도 반영하고 있습니다.
OAuth 2.0 프로토콜은 OAuth 1.0과 호환되지 않습니다.
두 버전(OAuth 1.0과 2.0)은 네트워크에서 공존할 수 있으며, 구현체는 둘 다 지원하도록 선택할 수 있습니다.
그러나 이 사양의 의도는 새로운 구현체가 본 문서에서 명시한 대로 OAuth 2.0을 지원하는 것이며, OAuth 1.0은 기존 배포 환경을 지원하는 용도로만 사용되는 것입니다.
OAuth 2.0 프로토콜은 OAuth 1.0 프로토콜과 구현 방식에서 거의 공통점을 갖지 않습니다.
따라서 OAuth 1.0에 익숙한 구현자는 이 문서의 구조와 세부 사항에 대해 어떠한 선입견도 가지지 않고 접근해야 합니다.

### 1.1 역할

OAuth는 네 가지 역할을 정의합니다.

#### 리소스 소유자 (Resource Owner)

보호된 리소스에 대한 접근 권한을 부여할 수 있는 주체.
리소스 소유자가 사람일 경우, 이를 최종 사용자(end-user)라고 합니다.

#### 리소스 서버 (Resource Server)

보호된 리소스를 호스팅하는 서버로, 액세스 토큰을 사용한 보호된 리소스 요청을 수락하고 응답할 수 있습니다.

#### 클라이언트 (Client)

리소스 소유자를 대신하여 보호된 리소스 요청을 수행하는 애플리케이션이며, 리소스 소유자의 인가를 받아야 합니다.
"클라이언트"라는 용어는 특정한 구현 방식(예: 서버, 데스크톱, 기타 기기에서 실행되는지 여부)을 의미하지 않습니다.

#### 인가 서버 (Authorization server)

리소스 소유자를 성공적으로 인증하고 인가를 받은 후, 클라이언트에게 액세스 토큰을 발급하는 서버.

Auth 사양에서는 인가 서버와 리소스 서버가 서로 어떻게 통신하는지에 대해 구체적으로 정의하지 않습니다.
인가 서버는 리소스 서버와 동일한 서버일 수도 있고, 별도의 엔티티일 수도 있습니다.
또한, 하나의 인가 서버가 여러 리소스 서버에서 사용할 수 있는 액세스 토큰을 발급할 수도 있습니다.

### 1.2. 프로토콜 흐름

```mermaid
sequenceDiagram
  participant A as 클라이언트
  participant B as 리소스 소유자
  participant C as 인가 서버
  participant D as 리소스 서버

  A->>B: (A) 인가 요청
  B->>A: (B) 인가 승인
  A->>C: (C) 인가 승인
  C->>A: (D) 액세스 토큰
  A->>D: (E) 액세스 토큰
  D->>A: (F) 보호된 리소스
```
그림 1. 추상적 프로토콜 흐름

그림 1에 나타난 추상적인 OAuth 2.0 흐름은 네 가지 역할 간의 상호작용을 설명하며, 다음 단계를 포함합니다.

(A) 클라이언트는 리소스 소유자로부터 인가를 요청합니다.
인가 요청은 리소스 소유자에게 직접 이루어질 수도 있으며(그림에서처럼), 일반적으로는 인가 서버를 중개자로 하여 간접적으로 이루어지는 것이 바람직합니다.

(B) 클라이언트는 인가 승인(authorization grant)을 받으며, 이는 리소스 소유자의 인가를 나타내는 자격 증명(credential)입니다.
이 자격 증명은 이 사양에서 정의한 네 가지 승인 유형 중 하나로 표현되거나, 확장 승인 유형을 사용할 수도 있습니다.
인가 승인 유형은 클라이언트가 인가를 요청하는 방식과 인가 서버에서 지원하는 유형에 따라 달라집니다.

(C) 클라이언트는 인가 서버에서 인증을 수행하고 인가 승인을 제시하여 액세스 토큰을 요청합니다.

(D) 인가 서버는 클라이언트를 인증하고 인가 승인을 검증한 후, 유효할 경우 액세스 토큰을 발급합니다.

(E) 클라이언트는 리소스 서버에서 보호된 리소스를 요청하며, 액세스 토큰을 제시하여 인증을 수행합니다.

(F) 리소스 서버는 액세스 토큰을 검증하고, 유효할 경우 요청을 처리합니다.

클라이언트가 리소스 소유자로부터 인가 승인을 받는 선호되는 방법(단계 (A)와 (B)에서 설명됨)은 인가 서버를 중개자로 사용하는 것입니다.
이는 [4.1절](#41-인가-코드-승인)의 그림 3에서 설명됩니다.

### 1.3. 인가 승인

인가 승인(authorization grant)은 리소스 소유자의 인가(보호된 리소스에 대한 접근 권한)를 나타내는 자격 증명으로, 클라이언트가 액세스 토큰을 얻기 위해 사용합니다.
이 사양에서는 네 가지 인가 승인 유형(인가 코드 방식, 암묵적 승인 방식, 리소스 소유자 비밀번호 인증 방식, 클라이언트 자격 증명 방식)을 정의하며, 추가적인 승인 유형을 정의할 수 있는 확장 메커니즘도 제공합니다.

#### 1.3.1. 인가 코드

인가 코드는 인가 서버를 클라이언트와 리소스 소유자 간의 중개자로 사용하여 얻어집니다.
클라이언트가 리소스 소유자에게 직접 인가를 요청하는 대신, 리소스 소유자를 인가 서버로 안내합니다([RFC2616](https://datatracker.ietf.org/doc/html/rfc2616)에서 정의한 사용자 에이전트를 통해).
그런 다음, 인가 서버는 리소스 소유자를 인가 코드와 함께 다시 클라이언트로 리디렉션합니다.

인가 서버는 리소스 소유자를 인가 코드와 함께 클라이언트로 리디렉션하기 전에, 리소스 소유자를 인증하고 인가를 획득합니다.
리소스 소유자는 오직 인가 서버에서만 인증을 수행하므로, 리소스 소유자의 자격 증명은 클라이언트와 절대 공유되지 않습니다.

인가 코드는 몇 가지 중요한 보안상의 이점을 제공합니다.
예를 들어, 클라이언트를 인증할 수 있는 기능이 있으며, 또한 액세스 토큰을 리소스 소유자의 사용자 에이전트를 거치지 않고 클라이언트에게 직접 전달할 수 있어, 리소스 소유자를 포함한 다른 사람에게 노출될 가능성을 줄일 수 있습니다.

#### 1.3.2. 암묵적 승인

암묵적 승인(Implicit Grant)은 브라우저에서 JavaScript와 같은 스크립트 언어를 사용하여 구현된 클라이언트에 최적화된 단순화된 인가 코드 흐름입니다.
암묵적 흐름에서는 클라이언트에게 인가 코드를 발급하는 대신, 리소스 소유자의 인가 결과로 직접 액세스 토큰이 발급됩니다.
이 승인 유형을 암묵적(implicit)이라고 하는 이유는, 인가 코드와 같은 중간 자격 증명이 발급되지 않으며, 따라서 이를 액세스 토큰을 얻는 데 사용할 수도 없기 때문입니다.

암묵적 승인 흐름에서 액세스 토큰을 발급할 때, 인가 서버는 클라이언트를 인증하지 않습니다.
일부 경우, 클라이언트의 신원은 액세스 토큰을 전달하는 데 사용된 리디렉션 URI를 통해 확인할 수 있습니다.
그러나 액세스 토큰은 리소스 소유자 또는 리소스 소유자의 사용자 에이전트(user-agent)에 접근할 수 있는 다른 애플리케이션에 노출될 수 있습니다.

암묵적 승인 방식은 일부 클라이언트(예: 브라우저 내에서 실행되는 애플리케이션)의 응답 속도와 효율성을 향상시킵니다.
왜냐하면 액세스 토큰을 얻는 데 필요한 왕복 요청 횟수를 줄이기 때문입다.
그러나 이러니 편의성은 암묵적 승인 방식을 사용할 때 발생하는 보안 문제([10.3](#103-액세스-토큰)절 및 [10.16](#1016-암묵적-승인-흐름에서-액세스-토큰-오용)절에서 설명됨)와 비교하여 신중히 고려해야 하며, 특히 인가 코드 승인 방식이 사용 가능한 경우 더욱 그렇습니다.

#### 1.3.3. 리소스 소유자 비밀번호 자격 증명

리소스 소유자의 비밀번호 자격 증명(즉, 사용자 이름과 비밀번호)은 인가 승인으로 직접 사용되어 액세스 토큰을 얻을 수 있습니다.
그러나 이 자격 증명은 리소스 소유자와 클라이언트 간의 신뢰 수준이 매우 높은 경우에만 사용해야 합니다(예: 클라이언트가 장치 운영 체제의 일부이거나, 높은 권한을 가진 애플리케이션인 경우).
또한, 인가 코드와 같은 다른 인가 승인 유형을 사용할 수 없는 경우에만 사용해야 합니다.

이 승인 유형은 클라이언트가 리소스 소유자의 자격 증명에 직접 접근해야 하지만, 자격 증명은 한 번만 사용되며 액세스 토큰으로 교환됩니다.
이 승인 유형은 클라이언트가 향후 사용을 위해 리소스 소유자의 자격 증명을 저장해야 하는 필요성을 없앨 수 있으며, 대신 장기간 유효한 액세스 토큰 또는 리프레시 토큰으로 교환하여 사용할 수 있습니다.

#### 1.3.4. 클라이언트 자격 증명

클라이언트 자격 증명(또는 다른 형태의 클라이언트 인증)은 인가 승인으로 사용될 수 있습니다.
이는 인가 범위가 클라이언트의 관리하에 있는 보호된 리소스로 제한되거나, 인가 서버와 사전에 협의된 보호된 리소스에 대한 접근일 때 가능합니다.
일반적으로, 클라이언트가 자체적으로 행동하는 경우(즉, 클라이언트가 곧 리소스 소유자인 경우) 또는 인가 서버와 사전에 협의된 인가를 기반으로 보호된 리소스에 대한 접근을 요청하는 경우, 클라이언트 자격 증명은 인가 승인으로 사용됩니다.

### 1.4. 액세스 토큰

액세스 토큰은 보호된 리소스에 접근하는 데 사용되는 자격 증명입니다.
액세스 토큰은 클라이언트에게 발급된 인가를 나타내는 문자열이며, 일반적으로 클라이언트에게 불투명합니다.
토큰은 특정 접근 범위와 유효 기간을 나타내며, 이러한 접근 권한은 리소스 소유자가 부여하고, 리소스 서버와 인가 서버가 이를 강제합니다.

토큰은 인가 정보를 가져오기 위한 식별자로 사용될 수도 있고, 검증 가능한 방식으로 자체적으로 인가 정보를 포함할 수도 있습니다(즉, 일부 데이터와 서명으로 구성된 토큰 문자열).
또한, 이 사양의 범위를 벗어난 추가적인 인증 자격 증명이 클라이언트가 토큰을 사용하기 위해 필요할 수도 있습니다.

액세스 토큰은 추상화 계층을 제공하며, 다양한 인가 방식(예: 사용자 이름과 비밀번호)을 리소스 서버가 이해할 수 있는 단일 토큰으로 대체합니다.
이 추상화 계층을 통해, 액세스 토큰은 이를 발급받은 인가 승인보다 더 제한적인 권한을 가질 수 있으며, 또한 리소스 서버가 다양한 인증 방식을 이해할 필요성을 제거합니다.

액세스 토큰은 리소스 서버의 보안 요구 사항에 따라 다양한 형식, 구조, 및 활용 방법(예: 암호학적 속성)을 가질 수 있습니다.
액세스 토큰의 속성과 보호된 리소스에 접근하는 방식은 이 사양의 범위를 벗어나며, 이는 [RFC6750](https://datatracker.ietf.org/doc/html/rfc6750)과 같은 관련된 사양에서 정의됩니다.

### 1.5. 리프레시 토큰

리프레시 토큰은 액세스 토큰을 얻기 위해 사용되는 자격 증명입니다.
리프레시 토큰은 인가 서버가 클라이언트에게 발급하며, 기존 액세스 토큰이 만료되거나 유효하지 않게 되었을 때 새로운 액세스 토큰을 얻는 데 사용됩니다.
또한, 동일하거나 더 제한적인 범위를 가진 추가적인 액세스 토큰을 얻는 데 사용할 수도 있습니다(액세스 토큰은 리소스 소유자가 부여한 권한보다 더 짧은 수명을 가지거나 더 적은 권한을 가질 수도 있습니다).
리프레시 토큰을 발급하는 것은 인가 서버의 재량에 따른 선택 사항이며, 인가 서버가 리프레시 토큰을 발급하는 경우, 이는 액세스 토큰을 발급할 때 함께 포함됩니다(즉, 그림 1의 단계 (D)).

리프레시 토큰은 리소스 소유자가 클라이언트에게 부여한 인가를 나타내는 문자열입니다.
이 문자열은 일반적으로 클라이언트에게 불투명하며, 인가 정보를 가져오는 데 사용되는 식별자를 나타냅니다.
액세스 토큰과 달리, 리프레시 토큰은 오직 인가 서버에서만 사용되며, 리소스 서버로 절대 전송되지 않습니다.

```mermaid
sequenceDiagram
    participant A as 클라이언트
    participant B as 리소스 서버
    participant C as 인가 서버

  A->>C: (A) 인가 승인
  C->>A: (B) 액세스 토큰 & 리프레시 토큰
  A->>B: (C) 액세스 토큰
  B->>A: (D) 보호된 리소스
  A->>B: (E) 액세스 토큰
  B->>A: (F) 유효하지 않은 토큰 오류
  A->>C: (G) 리프레시 토큰
  C->>A: (H) 액세스 토큰&선택적 리프레시 토큰
```
그림 2. 만료된 액세스 토큰 갱신 과정

그림 2에 설명된 흐름은 다음 단계를 포함합니다.

(A) 클라이언트는 인가 서버에 인증을 수행하고, 인가 승인을 제출하여 액세스 토큰을 요청합니다.

(B) 인가 서버는 클라이언트를 인증하고, 인가 승인을 검증한 후, 유효하면 액세스 토큰과 리프레시 토큰을 발급합니다.

(C) 클라이언트는 액세스 토큰을 제시하여 리소스 서버에 보호된 리소스를 요청합니다.

(D) 리소스 서버는 액세스 토큰을 검증하고, 유효하면 요청을 처리합니다.

(E) 액세스 토큰이 만료될 때까지 단계 (C)와 (D)가 반복됩니다.
클라이언트가 액세스 토큰이 만료되었음을 알면, 단계 (G)로 건너뜁니다.
그렇지 않으면, 클라이언트는 보호된 리소스를 다시 요청합니다.

(F) 액세스 토큰이 유효하지 않기 때문에, 리소스 서버는 '유효하지 않은 토큰' 오류를 반환합니다.

(G) 클라이언트는 인가 서버에 인증을 수행하고 리프레시 토큰을 제출하여 새로운 액세스 토큰을 요청합니다.
클라이언트 인증 요구 사항은 클라이언트 유형과 인가 서버의 정책에 따라 결정됩니다.

(H) 인가 서버는 클라이언트를 인증하고 리프레시 토큰을 검증한 후, 유효하면 새로운 액세스 토큰(및 선택적으로 새로운 리프레시 토큰)을 발급합니다.

단계 (C), (D), (E), (F)는 [7장](7-보호된-리소스-접근)에서 설명한 대로 이 사양의 범위를 벗어납니다.

### 1.6. TLS 버전

이 사양에서 전송 계층 보안(TLS)을 사용할 때, 적절한 TLS 버전(또는 여러 버전)은 광범위한 배포 현황과 알려진 보안 취약점에 따라 시간이 지나면서 달라질 수 있습니다.
이 문서가 작성된 시점에서, TLS 1.2([RFC5246](https://datatracker.ietf.org/doc/html/rfc5246))가 가장 최신 버전이지만, 배포 기반이 매우 제한적이며 구현하기 쉽지 않을 수도 있습니다.
반면, TLS 1.0([RFC2246](https://datatracker.ietf.org/doc/html/rfc2246))은 가장 널리 배포된 버전이며, 가장 넓은 범위의 상호운용성을 제공할 것입니다.
또한, 구현체는 보안 요구 사항을 충족하는 추가적인 전송 계층 보안 메커니즘을 지원할 수도 있습니다(MAY).

### 1.7. HTTP 리디렉션

이 사양은 HTTP 리디렉션을 광범위하게 사용하며, 여기서 클라이언트 또는 인가 서버는 리소스 소유자의 사용자 에이전트를 다른 목적지로 이동시킵니다.
이 사양의 예제에서는 HTTP 302 상태 코드를 사용하는 것으로 되어 있지만, 사용자 에이전트를 통해 이 리디렉션을 수행할 수 있는 다른 방법도 허용되며, 이는 구현 세부 사항으로 간주됩니다.

### 1.8. 상호 운용성

OAuth 2.0은 명확하게 정의된 보안 속성을 갖춘 강력한 인가 프레임워크를 제공합니다.
그러나 다양한 기능을 갖추고 확장성이 높은 프레임워크이며 선택적 요소가 많기 때문에, 이 사양만으로는 다양한 비호환적인 구현이 발생할 가능성이 큽니다.

또한, 이 사양에서는 일부 필수 구성 요소를 부분적으로 또는 완전히 정의하지 않고 있습니다(예: 클라이언트 등록, 인가 서버 기능, 엔드포인트 탐색).
이러한 구성 요소가 없으면, 클라이언트는 특정 인가 서버 및 리소스 서버와 상호운용하기 위해 수동으로 개별적인 구성을 해야 합니다.

이 프레임워크는 미래의 작업을 통해 구체적인 프로파일과 확장이 정의될 것이라는 명확한 기대를 가지고 설계되었습니다.
이는 완전한 웹 규모의 상호운용성을 달성하는 데 필요합니다.

### 1.9. 표기 규칙

이 사양에서 사용되는 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'MAY', 'OPTIONAL'이라는 키워드는 [RFC2119](https://datatracker.ietf.org/doc/html/rfc2119)에서 정의된 대로 해석되어야 합니다.

이 사양에서는 [RFC5234](https://datatracker.ietf.org/doc/html/rfc5234)에 정의된 확장된 백우스-나우어 형식(ABNF) 표기법을 사용하며, 또한 'Uniform Resource Identifier (URI): Generic Syntax' [RFC3986](https://datatracker.ietf.org/doc/html/rfc3986)에서 정의된 URI-reference 규칙을 포함합니다.

특정 보안 관련 용어는 [RFC4949](https://datatracker.ietf.org/doc/html/rfc4949)에서 정의된 의미로 이해해야 하며, 여기에는 '공격(attack)', '인증(authentication)', '인가(authorization)', '인증서(certificate)', '기밀성(confidentiality)', '자격 증명(credential)', '암호화(encryption)', '신원(identity)', '서명(sign)', '신뢰(trust)', '검증(validate)', '확인(verify)' 등이 포함되지만, 이에 국한되지는 않습니다.

별도의 언급이 없는 한, 모든 프로토콜 매개변수 이름과 값은 대소문자를 구분합니다.

## 2. 클라이언트 등록

OAuth 2.0 프로토콜을 시작하기 전, 클라이언트는 인가 서버에 등록해야 합니다.
클라이언트가 인가 서버에 등록하는 방법은 이 명세의 범위를 벗어나지만 일반적으로 HTML 등록 양식을 통해 엔드 유저와 상호 작용하는 것을 포함합니다.

클라이언트 등록 과정은 클라이언트와 인가 서버 간의 직접적인 상호 작용을 필수로 요구하지 않습니다.
인가 서버가 지원하기만 한다면, 상호 간 신뢰를 확립하고 필요한 클라이언트 속성 (예: 리디렉션 URI, 클라이언트 타입) 을 얻기 위해 다른 방법을 사용할 수 있습니다.
예를 들어, 클라이언트 등록 과정은 자체적으로 또는 제3자가 발급한 증명서를 사용하거나
신뢰할 수 있는 창구를 통해 인가 서버가 클라이언트를 탐색하여 등록을 수행하는 방식이 될 수 있습니다.

클라이언트를 등록할 때, 클라이언트 개발자는 다음을 수행해야 합니다 (SHALL).

- 2.1절에서 설명한 클라이언트 유형을 지정해야 합니다.
- 3.1.2절에서 설명한 클라이언트 리디렉션 URI를 제공해야 합니다.
- 인가 서버가 요구하는 다른 정보를 포함해야 합니다. (예: 애플리케이션 이름, 웹사이트, 설명, 로고 이미지, 약관 동의 등)

### 2.1 클라이언트 유형

OAuth는 클라이언트가 인가 서버와 안전하게 인증할 수 있는 능력 (예: 클라이언트 자격 증명의 기밀성을 유지할 수 있는 능력)
에 따라 두 가지 클라이언트 유형을 정의합니다.

- 신뢰할 수 있는 클라이언트 (confidential)
  - 자격 증명의 기밀성을 유지할 수 있는 클라이언트 (예: 클라이언트의 기밀 정보에 제한된 액세스를 가진 안전한 서버에 구현된 클라이언트)
  - 또는 다른 방법을 사용하여 안전한 클라이언트 인증이 가능한 클라이언트

- 공개 클라이언트 (public)
  - 자격 증명의 기밀성을 유지할 수 없는 클라이언트 (예: 리소스 소유자가 사용하는 장치에 설치된 네이티브 애플리케이션 또는 웹 브라우저 기반 애플리케이션)
  - 다른 방법으로 안전한 클라이언트 인증이 불가능한 클라이언트

클라이언트 유형의 지정은
인가 서버가 정의하는 안전한 인증이 무엇인지와 클라이언트 자격 증명의 노출을 어느 정도로 허용할지의 기준에 기반합니다. 인가 서버는 클라이언트 유형에 대한 가정을 해서는 안됩니다 (SHOULD NOT).

어떤 클라이언트는 서로 다른 클라이언트 유형과 보안 컨텍스트를 가진 분산된 구성 요소들의 집합으로 구현될 수도 있습니다.
(예: 기밀 서버 기반 구성 요소와 공개 브라우저 기반 구성 요소를 모두 가진 분산 클라이언트).
인증 서버가 이러한 유형의 클라이언트를 지원하지 않거나 클라이언트 등록에 대한 지침을 제공하지 않는 경우,
클라이언트는 각 구성 요소를 별개의 클라이언트로 등록해야 합니다 (SHOULD).

이 명세는 다음 클라이언트 프로필을 기반으로 작성되었습니다:

- web application (웹 어플리케이션)
  - 웹 어플리케이션은 웹 서버에서 실행되는 신뢰할 수 있는 클라이언트 (confidential client) 입니다. 리소스 소유자는 리소스 소유자가 사용하는 기기의 사용자 에이전트 (user-agent) 에서 렌더링된 HTML 사용자 인터페이스를 통해 클라이언트에 접근합니다. 클라이언트 자격 증명과 클라이언트에게 발급된 액세스 토큰은 웹 서버에 저장되어 리소스 소유자에게 노출되거나 접근할 수 없습니다.
- user-agent-based application (사용자 에이전트 기반 어플리케이션)
  - 사용자 에이전트 기반 어플리케이션은 클라이언트 코드가 웹 서버로부터 다운로드되고 리소스 소유자가 사용하는 기기의 사용자 에이전트 (예: 웹 브라우저) 내에서 실행되는 공개 클라이언트 (public client) 입니다. 프로토콜 데이터와 자격 증명은 리소스 소유자에게 쉽게 접근 가능하며 때로는 보이기도 합니다. 이러한 어플리케이션은 사용자 에이전트 내에 존재하기 때문에 인가 요청 시 사용자 에이전트 기능을 원활하게 사용할 수도 있습니다.
- native application (네이티브 어플리케이션)
  - 네이티브 어플리케이션은 리소스 소유자가 사용하는 기기에 설치 및 실행되는 공개 클라이언트입니다. 프로토콜 데이터와 자격 증명은 리소스 소유자에 의해 접근 가능하며 어플리케이션 내 클라이언트 인증 자격 증명은 추출될 수 있다고 가정합니다. 반면에 동적으로 발급되는 자격 증명 (액세스 토큰 또는 리프레시 토큰)은 적절한 수준의 보호를 받을 수 있습니다. 최소한 이러한 자격 증명은 어플리케이션이 상호 작용할 수 있는 악의적인 서버로부터 보호됩니다. 일부 플랫폼에서는 이러한 자격 증명이 동일한 기기에 존재하는 다른 어플리케이션으로부터 보호될 수도 있습니다.

### 2.2 클라이언트 식별자

인가 서버는 등록된 클라이언트에게 클라이언트 식별자를 발급합니다.
이는 클라이언트가 제공한 등록 정보를 나타내는 고유한 문자열입니다.
클라이언트 식별자는 비밀이 아니며 리소스 소유자에게 노출되어 있으므로 클라이언트 식별자만으로 클라이언트를 인증해서는 안됩니다 (MUST NOT).
클라이언트 식별자는 인가 서버마다 고유합니다.

클라이언트 식별자의 문자열 크기는 이 명세에 의해 정의되지 않습니다. 클라이언트는 식별자 크기에 대해 가정하는 것을 지양해야 합니다.
인가 서버는 발급하는 식별자의 크기를 문서화해야 합니다 (SHOULD).

### 2.3 클라이언트 인증

신뢰할 수 있는 클라이언트인 경우, 클라이언트와 인가 서버는 인가 서버의 보안 요구 사항에 적합한 클라이언트 인증 방법을 설정합니다.
인가 서버는 보안 요구 사항을 충족하는 클라이언트 인증 방법을 설정할 수 있습니다 (MAY).

신뢰할 수 있는 클라이언트에게는 일반적으로 인가 서버에 인증을 할 때 사용되는 클라이언트 자격 증명 세트 (예: 비밀번호, 공개/개인 키 쌍)가 발급됩니다.

인가 서버는 공개 클라이언트와도 클라이언트 인증 방법을 설정할 수 있으나 (MAY), 클라이언트를 식별하기 위해 공개 클라이언트 인증에 의존해서는 안됩니다 (MUST NOT).

클라이언트는 각 요청에 둘 이상의 인증 방법을 사용해서는 안됩니다 (MUST NOT).

#### 2.3.1 클라이언트 비밀번호

클라이언트 비밀번호를 보유한 클라이언트는 인가 서버와의 상호 작용을 위해 HTTP Basic 인증 방식을 사용할 수 있습니다. ([RFC2617](https://datatracker.ietf.org/doc/html/rfc2617) 참고)
클라이언트 식별자는 `application/x-www-form-urlencoded` 인코딩 알고리즘을 사용하여 인코딩되고 ([Appendix B](https://datatracker.ietf.org/doc/html/rfc6749#appendix-B) 참고) 인코딩된 값은 계정 이름 (계정ID, username) 으로 사용됩니다.
클라이언트 비밀번호 역시 동일한 알고리즘을 사용하여 인코딩되고 비밀번호로 사용됩니다.
인가 서버는 클라이언트 비밀번호를 발급받은 클라이언트를 인증하기 위한 방법으로 HTTP Basic 인증 방식을 반드시 지원해야 합니다 (MUST).

예시:

```text
Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3
```

대안으로는, 아래 파라미터를 사용하여 클라이언트 자격 증명을 요청 본문에 포함하는 방식을 지원할 수도 있습니다 (MAY).

- client_id
  - 필수. 2.2절의 클라이언트 등록 과정에서 클라이언트에게 발급된 식별자
- client_secret
  - 필수. 클라이언트 비밀번호. 클라이언트는 클라이언트 비밀번호가 빈 문자열인 경우 파라미터를 생략할 수 있습니다 (MAY).

위 파라미터의 클라이언트 자격 증명을 요청 본문에 포함하는 것은 권장되지 않으며 (NOT RECOMMENDED),
직접적으로 HTTP Basic 인증 방식 (혹은 다른 비밀번호 기반 HTTP 인증 방식) 을 사용할 수 없는 클라이언트에게 제한적으로 사용되어야 합니다 (SHOULD).
파라미터는 요청 본문을 통해서만 전송되어야 하며 요청 URI에 포함되어서는 안됩니다 (MUST NOT).

예시: 액세스 토큰을 새로고침하기 위해 (Section 6) 아래와 같은 바디 파라미터를 사용하는 요청

```http request
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
&client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
```

1.6절에 명시한 것처럼, 인가 서버는 비밀번호 인증을 사용하는 요청에 대해 TLS 사용을 요구해야 합니다 (MUST).

해당 인증 방식은 비밀번호를 포함하기 때문에 인가 서버는 이러한 방식을 사용하는 엔드포인트를 무차별 공격 (bruteforce attack) 으로부터 보호해야 합니다 (MUST).

#### 2.3.2 기타 인증 방법

인가 서버는 보안 요구 사항을 충족하는 다른 HTTP 인증 방식을 지원할 수 있습니다 (MAY).
다른 인증 방식을 사용하는 경우 인가 서버는 클라이언트 식별자 (클라이언트 등록 정보) 와 인증 방식 간의 매핑을 반드시 정의해야 합니다 (MUST).

### 2.4 미등록 클라이언트

이 명세는 등록되지 않은 클라이언트의 사용을 배제하진 않으나 이러한 클라이언트의 사용은 이 명세의 범위를 벗어나며 추가적인 보안 분석과 상호 운용성 영향 검토가 필요합니다.

## 3. 프로토콜 엔드포인트

인가 프로세스는 인가 서버 측의 두 개의 엔드포인트(HTTP 리소스)를 사용합니다:

- 인가 엔드포인트(authorization endpoint) - 클라이언트가 유저 에이전트(user-agent) 리다이렉션을 통해 리소스 소유자로부터 인가를 받기 위해 사용합니다.
- 토큰 엔드포인트(token endpoint) - 클라이언트가 인가 권한을 접근 토큰으로 교환하기 위해 사용하며, 일반적으로 클라이언트 인증이 필요합니다.

또한 클라이언트 측에는 다음의 엔드포인트가 필요합니다:

- 리디렉션 엔드포인트(redirect endpoint) - 인가 서버가 리소스 소유자의 유저 에이전트를 통해 클라이언트에게 인가 자격 증명이 포함된 응답을 반환하기 위해 사용합니다.

모든 인가 승인 유형이 두 엔드포인트를 모두 사용하는 것은 아닙니다. 확장 승인 유형은 필요에 따라 추가 엔드포인트를 정의할 수 있습니다(MAY).

### 3.1 인가 엔드포인트

인가 엔드포인트는 리소스 소유자와 상호작용하고 인가 승인을 얻기 위해 사용됩니다. 인가 서버는 먼저 리소스 소유자의 신원을 확인해야 합니다(MUST). 인가 서버가 리소스 소유자를 인증하는 방법(예: 사용자 이름과 비밀번호 로그인, 세션 쿠키)은 이 명세서의 범위를 벗어납니다.

클라이언트가 인가 엔드포인트의 위치를 얻는 방법은 이 명세서의 범위를 벗어납니다. 일반적으로 서비스 문서에서 제공됩니다.

엔드포인트 URI는 `application/x-www-form-urlencoded` 형식(부록 B 참조)의 쿼리 컴포넌트([RFC3986] Section 3.4)를 포함할 수 있으며, 이는 추가 쿼리 매개변수를 추가할 때 유지되어야 합니다(MUST). 엔드포인트 URI는 프래그먼트 컴포넌트를 포함해서는 안 됩니다(MUST NOT).

인가 엔드포인트로의 요청은 사용자 인증과 암호화되지 않은 인증 정보가 HTTP 응답으로 전송되므로, 인가 서버는 해당 엔드포인트로 요청을 보낼 때 1.6절에 설명된 대로 TLS 사용을 요구해야 합니다(MUST).

인가 서버는 인가 엔드포인트에 대해 HTTP `GET` 메서드[RFC2616]를 지원해야 하며(MUST), `POST` 메서드도 지원할 수 있습니다(MAY).

값 없이 전송된 매개변수는 요청에서 생략된 것처럼 처리되어야 합니다(MUST). 인가 서버는 인식되지 않은 요청 매개변수를 무시해야 합니다(MUST). 요청 및 응답 매개변수는 두 번 이상 포함되어서는 안 됩니다(MUST NOT).

#### 3.1.1 응답 유형

인가 엔드포인트는 인가 코드 승인 방식과 암묵적 승인 방식 흐름에서 사용됩니다. 클라이언트는 다음 매개변수를 사용하여 원하는 승인 유형을 인가 서버에 알립니다:

`response_type`
필수(REQUIRED). 값은 4.1.1절에 설명된 대로 인가 코드를 요청하는 `code`, 4.2.1절에 설명된 대로 접근 토큰(암묵적 승인)을 요청하는 `token`, 또는 8.4절에 설명된 등록된 확장 값 중 하나여야 합니다.

확장 응답 유형은 공백(%x20)으로 구분된 값 목록을 포함할 수 있으며, 값의 순서는 중요하지 않습니다(예: 응답 유형 `a b`는 `b a`와 동일). 이러한 복합 응답 유형의 의미는 각각의 명세서에 의해 정의됩니다.

인가 요청에 `response_type` 매개변수가 없거나 응답 유형이 이해되지 않는 경우, 인가 서버는 4.1.2.1절에 설명된 대로 오류 응답을 반환해야 합니다(MUST).

#### 3.1.2 리디렉션 엔드포인트

리소스 소유자와의 상호 작용을 완료한 후, 인가 서버는 리소스 소유자의 유저 에이전트를 클라이언트로 다시 돌려보냅니다. 인가 서버는 유저 에이전트를 클라이언트 등록 과정 중에 또는 인가 요청을 할 때 인가 서버와 함께 이전에 설정된 클라이언트의 리디렉션 엔드포인트로 리디렉션합니다.

리디렉션 엔드포인트 URI는 [RFC3986] 4.3절에 정의된 대로 절대 URI여야 합니다(MUST). 엔드포인트 URI는 `application/x-www-form-urlencoded` 형식의 쿼리 컴포넌트를 포함할 수 있으며, 이는 추가 쿼리 매개변수를 추가할 때 유지되어야 합니다(MUST). 엔드포인트 URI는 프래그먼트 컴포넌트를 포함해서는 안 됩니다(MUST NOT).

##### 3.1.2.1 엔드포인트 요청 기밀성

리디렉션 엔드포인트는 요청된 응답 유형이 `code` 또는 `token`인 경우, 또는 리디렉션 요청이 개방형 네트워크를 통해 민감한 자격 증명을 전송하게 되는 경우, 섹션 1.6에 설명된 대로 TLS 사용을 요구해야 합니다(SHOULD). 이 명세서가 작성되는 시점에서 클라이언트 개발자들에게 TLS 배포를 요구하는 것이 상당한 장애물이 되기 때문에, 이 명세서는 TLS 사용을 의무화하지는 않습니다. TLS를 사용할 수 없는 경우, 인가 서버는 리디렉션 전에 리소스 소유자에게 안전하지 않은 엔드포인트에 대해 경고해야 합니다(SHOULD)(예: 인가 요청 중 메시지 표시).

전송 계층 보안의 부재는 클라이언트와 클라이언트가 접근 권한을 부여받은 보호된 리소스의 보안에 심각한 영향을 미칠 수 있습니다. 특히 인가 프로세스가 클라이언트에 의해 위임된 최종 사용자 인증의 형태로 사용되는 경우(예: 제3자 로그인 서비스), 전송 계층 보안의 사용이 매우 중요합니다.

##### 3.1.2.2 등록 요구사항

인가 서버는 다음 클라이언트들이 그들의 리디렉션 엔드포인트를 등록하도록 요구해야 합니다(MUST):

- 공개 클라이언트
- 암묵적 승인 방식을 사용하는 신뢰할 수 있는 클라이언트

인가 서버는 모든 클라이언트가 인가 엔드포인트를 사용하기 전에 리디렉션 엔드포인트를 등록하도록 요구해야 합니다(SHOULD).

인가 서버는 클라이언트가 완전한 리디렉션 URI를 제공하도록 요구해야 합니다(SHOULD)(클라이언트는 요청별 사용자 지정을 위해 `state` 요청 매개변수를 사용할 수 있음). 완전한 리디렉션 URI의 등록을 요구하는 것이 불가능한 경우, 인가 서버는 URI 스키마, 권한, 경로의 등록을 요구해야 합니다(SHOULD)(클라이언트가 인가를 요청할 때 리디렉션 URI의 쿼리 컴포넌트만 동적으로 변경할 수 있도록 허용).

인가 서버는 클라이언트가 여러 리디렉션 엔드포인트를 등록하는 것을 허용할 수 있습니다(MAY).

리디렉션 URI 등록 요구사항의 부재는 10.15절에 설명된 대로 공격자가 인가 엔드포인트를 오픈 리디렉터로 사용할 수 있게 할 수 있습니다.

##### 3.1.2.3 동적 구성

여러 리디렉션 URI가 등록된 경우, 리디렉션 URI의 일부만 등록된 경우, 또는 리디렉션 URI가 등록되지 않은 경우, 클라이언트는 `redirect_uri` 요청 매개변수를 사용하여 인가 요청에 리디렉션 URI를 포함해야 합니다(MUST).

리디렉션 URI가 인가 요청에 포함된 경우, 인가 서버는 받은 값을 등록된 리디렉션 URI(또는 URI 컴포넌트) 중 하나와 비교하고 일치시켜야 합니다(MUST)([RFC3986] 6절에 정의된 대로). 클라이언트 등록에 완전한 리디렉션 URI가 포함된 경우, 인가 서버는 [RFC3986] 6.2.1절에 정의된 대로 단순 문자열 비교를 사용하여 두 URI를 비교해야 합니다(MUST).

##### 3.1.2.4 잘못된 엔드포인트

인가 요청이 리디렉션 URI가 누락되었거나, 잘못되었거나, 일치하지 않아 유효성 검사에 실패한 경우, 인가 서버는 리소스 소유자에게 오류를 알려야 하며 유저 에이전트를 잘못된 리디렉션 URI로 자동 리디렉션해서는 안 됩니다(MUST NOT).

##### 3.1.2.5 엔드포인트 내용

클라이언트의 엔드포인트로의 리디렉션 요청은 일반적으로 유저 에이전트가 처리하는 HTML 문서 응답을 초래합니다. HTML 응답이 리디렉션 요청의 직접적인 결과로 제공되는 경우, HTML 문서에 포함된 모든 스크립트는 리디렉션 URI와 그 안에 포함된 자격 증명에 대한 전체 접근 권한으로 실행됩니다.

클라이언트는 리디렉션 엔드포인트 응답에 제3자 스크립트(예: 제3자 분석, 소셜 플러그인, 광고 네트워크)를 포함해서는 안 됩니다(SHOULD NOT). 대신, URI에서 자격 증명을 추출하고 유저 에이전트를 자격 증명을 노출하지 않는(URI 또는 다른 곳에서) 다른 엔드포인트로 다시 리디렉션해야 합니다(SHOULD). 제3자 스크립트가 포함된 경우, 클라이언트는 자체 스크립트(URI에서 자격 증명을 추출하고 제거하는 데 사용됨)가 먼저 실행되도록 보장해야 합니다(MUST).

### 3.2 토큰 엔드포인트

토큰 엔드포인트는 클라이언트가 인가 승인이나 리프레시 토큰(refresh token)을 제시하여 접근 토큰을 얻기 위해 사용됩니다. 토큰 엔드포인트는 암묵적 승인 유형을 제외한 모든 인가 승인과 함께 사용됩니다(접근 토큰이 직접 발급되기 때문).

클라이언트가 토큰 엔드포인트의 위치를 얻는 방법은 이 명세서의 범위를 벗어납니다. 일반적으로 서비스 문서에서 제공됩니다.

엔드포인트 URI는 `application/x-www-form-urlencoded` 형식의 쿼리 컴포넌트를 포함할 수 있으며, 이는 추가 쿼리 매개변수를 추가할 때 유지되어야 합니다(MUST). 엔드포인트 URI는 프래그먼트 컴포넌트를 포함해서는 안 됩니다(MUST NOT).

토큰 엔드포인트에 대한 요청은 암호화되지 않은 자격 증명이 HTTP 요청과 응답으로 전송되므로, 인가 서버는 토큰 엔드포인트에 요청을 보낼 때 1.6절에 설명된 대로 TLS 사용을 요구해야 합니다(MUST).

클라이언트는 접근 토큰 요청을 할 때 HTTP `POST` 메서드를 사용해야 합니다(MUST).

값 없이 전송된 매개변수는 요청에서 생략된 것처럼 처리되어야 합니다(MUST). 인가 서버는 인식되지 않은 요청 매개변수를 무시해야 합니다(MUST). 요청 및 응답 매개변수는 두 번 이상 포함되어서는 안 됩니다(MUST NOT).

#### 3.2.1 클라이언트 인증

신뢰할 수 있는 클라이언트나 클라이언트 자격 증명을 발급받은 다른 클라이언트들은 토큰 엔드포인트에 요청할 때 섹션 2.3에서 설명된 대로 반드시(MUST) 인가 서버에 대해 인증을 수행해야 합니다. 클라이언트 인증은 다음과 같은 목적으로 사용됩니다:

- 리프레시 토큰과 인가 코드가 원래 발급된 클라이언트에게만 바인딩되도록 강제합니다. 클라이언트 인증은 특히 인가 코드가 안전하지 않은 채널을 통해 리다이렉션 엔드포인트로 전송되거나, 리디렉션 URI가 완전히 등록되지 않은 경우에 매우 중요합니다.

- 클라이언트를 비활성화하거나 자격 증명을 변경함으로써 보안이 침해된 클라이언트로부터 복구할 수 있으며, 이는 공격자가 탈취한 리프레시 토큰을 악용하는 것을 방지합니다. 단일 클라이언트 자격 증명을 변경하는 것이 전체 리프레시 토큰 세트를 취소하는 것보다 훨씬 빠릅니다.

- 주기적인 자격 증명 갱신이 필요한 인증 관리 모범 사례를 구현합니다. 전체 리프레시 토큰 세트를 갱신하는 것은 어려울 수 있지만, 단일 클라이언트 자격 증명 세트를 갱신하는 것은 상대적으로 훨씬 쉽습니다.

클라이언트는 토큰 엔드포인트에 요청을 보낼 때 자신을 식별하기 위해 `client_id` 요청 매개변수를 사용할 수 있습니다(MAY). 토큰 엔드포인트에 대한 `authorization_code` `grant_type` 요청에서, 인증되지 않은 클라이언트는 다른 `client_id`를 가진 클라이언트에게 의도된 코드를 실수로 수락하는 것을 방지하기 위해 반드시 자신의 `client_id`를 전송해야 합니다(MUST). 이는 클라이언트를 인가 코드 교체로부터 보호합니다. (단, 보호된 리소스에 대한 추가적인 보안은 제공하지 않습니다.)

### 3.3 접근 토큰 범위

인가 및 토큰 엔드포인트는 클라이언트가 `scope` 요청 매개변수를 사용하여 접근 요청의 범위를 지정할 수 있게 합니다. 이에 대응하여, 인가 서버는 `scope` 응답 매개변수를 사용하여 발급된 접근 토큰의 범위를 클라이언트에 알립니다.

scope 매개변수의 값은 공백으로 구분된, 대소문자를 구분하는 문자열 목록으로 표현됩니다. 이 문자열들은 인가 서버에 의해 정의됩니다. 값이 여러 개의 공백으로 구분된 문자열을 포함하는 경우, 그 순서는 중요하지 않으며, 각 문자열은 요청된 범위에 추가적인 접근 범위를 추가합니다.

```ABNF
scope       = scope-token *( SP scope-token )
scope-token = 1*( %x21 / %x23-5B / %x5D-7E )
```

인가 서버는 인가 서버 정책이나 리소스 소유자의 지시에 따라 클라이언트가 요청한 범위를 완전히 또는 부분적으로 무시할 수 있습니다(MAY). 발급된 접근 토큰의 범위가 클라이언트가 요청한 것과 다른 경우, 인가 서버는 실제로 부여된 범위를 클라이언트에 알리기 위해 `scope` 응답 매개변수를 포함해야 합니다(MUST).

클라이언트가 인가를 요청할 때 scope 매개변수를 생략하는 경우, 인가 서버는 미리 정의된 기본값을 사용하여 요청을 처리하거나 유효하지 않은 범위를 나타내는 요청 실패를 해야 합니다(MUST). 인가 서버는 범위 요구사항과 기본값(정의된 경우)을 문서화해야 합니다(SHOULD).

## 4. 인가 승인 받기
액세스 토큰을 요청하기 위해 클라이언트는 리소스 소유자로부터 인가를 얻습니다.
그 인가는 ‘인가 승인’이라는 형태로 표현되며, 클라이언트는 이를 사용하여 액세스 토큰을 요청합니다.
OAuth는 네 가지 승인 유형을 정의한다: 인가 코드, 암묵적 승인, 리소스 소유자 비밀번호 인증, 클라이언트 인증 정보
또한 OAuth는 추가적인 승인 유형을 정의하기 위한 확장 메커니즘을 제공합니다.

### 4.1. 인가 코드 승인
인가 코드 승인 유형은 액세스 토큰과 리프레시 토큰을 얻기 위해 사용되며, 기밀성이 보장된 클라이언트에 최적화되어 있습니다.
이것은 리디렉션 기반 흐름입니다.
클라이언트는 리소스 소유자의 사용자 에이전트(일반적으로 웹 브라우저)와 상호작용할 수 있어야 하며,
또한 인가 서버로부터 리디렉션을 통해 들어오는 요청을 받을 수 있어야 합니다.

```mermaid
sequenceDiagram
    participant RO as 리소스 소유자
    participant UA as 사용자 에이전트
    participant AS as 인가 서버
    participant C as 클라이언트
    
   C->>UA: (A) 클라이언트 식별자 & 리디렉션 URI
   UA->>AS: (A) 클라이언트 식별자 & 리디렉션 URI
   UA->>AS: (B) 사용자 인증 진행
   UA->>RO: (B) 사용자 인증 진행
   AS->>UA: (C) 인가 코드
   UA->>C: (C) 인가 코드
   C->>AS: (D) 인가 코드 & 리디렉션 URI
   AS->>C: (E) 액세스 토큰 & 선택적 리프레시 토큰
```
참고: 단계 (A), (B), (C)를 나타내는 선들은 사용자 에이전트를 통과하면서 두 부분으로 나뉩니다.

그림 3. 인가 코드 흐름

그림 3에 도식화된 흐름은 다음 단계를 포함합니다.

(A) 클라이언트는 리소스 소유자의 사용자 에이전트를 인가 엔드포인트로 이동시킴으로써 흐름을 시작합니다.
클라이언트는 클라이언트 식별자, 요청된 범위, 로컬 상태, 그리고 인가 서버가 액세스를 허용(또는 거부)한 후 사용자 에이전트를 다시 보낼 리디렉션 URI를 포함합니다.

(B) 인가 서버는 사용자 에이전트를 통해 리소스 소유자를 인증합니다.
또한, 리소스 소유자가 클라이언트의 액세스 요청을 승인하는지 또는 거부하는지를 확인합니다.

(C) 리소스 소유자가 액세스를 승인한다고 가정하면, 인가 서버는 이전 요청 또는 클라이언트 등록 시 제공된 리디렉션 URI를 사용하여 사용자 에이전트를 클라이언트로 다시 리디렉트합니다.
리디렉션 URI에는 인가 코드와 클라이언트가 이전에 제공한 로컬 상태가 포함됩니다.

D) 클라이언트는 이전 단계에서 받은 인가 코드를 포함하여 인가 서버의 토큰 엔드포인트로부터 액세스 토큰을 요청합니다. 
요청을 보낼 때, 클라이언트는 인가 서버와 인증을 수행합니다.
또한, 클라이언트는 인가 코드를 얻는 데 사용된 리디렉션 URI를 검증을 위해 포함합니다.

(E) 인가 서버는 클라이언트를 인증하고, 인가 코드를 검증하며, 받은 리디렉션 URI가 (C) 단계에서 클라이언트를 리디렉트하는 데 사용된 URI와 일치하는지 보장합니다.
유효한 경우, 인가 서버는 액세스 토큰과 선택적으로 리프레시 토큰을 포함하여 응답합니다.

#### 4.1.1. 인가 요청
클라이언트는 부록 B에 따라 ‘application/x-www-form-urlencoded’ 형식을 사용하여 다음의 매개변수를 인가 엔드포인트 URI의 쿼리 컴포넌트에 추가하여 요청 URI를 구성합니다.

- response_type: 

  필수 항목(REQUIRED)입니다. 값은 반드시 ‘code’로 설정해야 합니다 (MUST).
- client_id: 

  필수 항목(REQUIRED)입니다. 클라이언트 식별자는 [섹션 2.2](#22-클라이언트-식별자)에서 설명된 대로 설정해야 합니다.
- redirect_uri: 

  선택 항목(OPTIONAL)입니다. [섹션 3.1.2](#312-리디렉션-엔드포인트)에서 설명된 대로 설정할 수 있습니다.
- scope: 

  선택 항목(OPTIONAL)입니다. 액세스 요청의 범위는 [섹션 3.3](#33-접근-토큰-범위)에서 설명된 대로 설정할 수 있습니다.
- state: 

  권장 항목(RECOMMENDED)입니다. 요청과 콜백 사이에서 상태를 유지하기 위해 클라이언트가 사용하는 불투명한 값입니다.
  인가 서버는 사용자 에이전트를 클라이언트로 다시 리디렉트할 때 이 값을 포함합니다.
  이 매개변수는 크로스 사이트 요청 위조(CSRF)를 방지하기 위해 사용해야 합니다 (SHOULD).
  자세한 내용은 [섹션 10.12](#1012-크로스-사이트-요청-위조-csrf)에서 설명하고 있습니다.

클라이언트는 HTTP 리디렉션 응답을 사용하거나, 사용자 에이전트를 통해 이용할 수 있는 다른 방법을 사용하여 리소스 소유자를 구성된 URI로 이동시킵니다.

예를 들어, 클라이언트는 사용자 에이전트에게 TLS를 사용하여 다음 HTTP 요청을 수행하도록 지시합니다.
(아래 요청은 가독성을 위해 추가 줄 바꿈이 포함되었습니다.)

```
    GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz
        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
    Host: server.example.com
```

인가 서버는 모든 필수 매개변수가 존재하며 유효한지 확인하기 위해 요청을 검증합니다.

요청이 유효한 경우, 인가 서버는 리소스 소유자를 인증하고 인가 결정을 얻습니다.
(이 과정은 리소스 소유자에게 직접 요청하거나, 다른 방법을 통해 승인을 확보하여 진행됩니다.)

인가 결정이 확립되었을 때, 인가 서버는 사용자 에이전트를 제공된 클라이언트 리디렉션 URI로 이동시킵니다.
이 과정은 HTTP 리디렉션 응답을 사용하거나, 사용자 에이전트를 통해 이용할 수 있는 다른 방법을 사용하여 진행됩니다.

#### 4.1.2. 인가 응답
리소스 소유자가 액세스 요청을 승인하는 경우, 인가 서버는 인가 코드를 발급하고 이를 클라이언트에게 전달합니다.
이 과정에서 부록 B에 따라 ‘application/x-www-form-urlencoded’ 형식을 사용하여 다음의 매개변수를 리디렉션 URI의 쿼리 컴포넌트에 추가합니다.

- code: 

  필수 항목(REQUIRED)입니다. 인가 서버가 생성한 인가 코드입니다.
  인가 코드는 유출 위험을 완화하기 위해 발급된 후 짧은 시간 내에 만료되어야 합니다 (MUST).
  인가 코드의 최대 유효 기간은 10분을 권장합니다 (RECOMMENDED).
  클라이언트는 인가 코드를 한 번 이상 사용해서는 안 됩니다 (MUST NOT).
  인가 코드가 한 번 이상 사용된 경우, 인가 서버는 해당 요청을 거부해야 합니다 (MUST).
  또한, 가능하다면 해당 인가 코드 기반으로 이전에 발급된 모든 토큰을 폐기하는 것이 권장됩니다 (SHOULD).
  인가 코드는 클라이언트 식별자와 리디렉션 URI에 연계됩니다.

- state

  클라이언트의 인가 요청에 state 매개변수가 포함된 경우, 필수 항목(REQUIRED)입니다.
  클라이언트로부터 받은 값과 정확히 동일한 값을 반환해야 합니다.

예를 들어, 인가 서버는 다음 HTTP 응답을 전송하여 사용자 에이전트를 리디렉트합니다.

```
    HTTP/1.1 302 Found
     Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA
               &state=xyz
```

클라이언트는 알 수 없는 응답 매개변수를 무시해야 합니다 (MUST).
인가 코드 문자열 크기는 이 명세서에서 정의되지 않았습니다.
클라이언트는 코드 값 크기에 대한 가정을 피해야 합니다.
인가 서버는 발급하는 값의 크기를 문서화하는 것이 권장됩니다 (SHOULD).

#### 4.1.2.1. 오류 응답
요청이 리디렉션 URI가 누락되었거나, 유효하지 않거나, 일치하지 않는 경우, 또는 클라이언트 식별자가 누락되었거나 유효하지 않은 경우, 인가 서버는 리소스 소유자에게 오류를 알려야 합니다 (SHOULD).
또한, 잘못된 리디렉션 URI로 사용자 에이전트를 자동으로 리디렉트해서는 안 됩니다 (MUST NOT).

리소스 소유자가 액세스 요청을 거부한 경우, 또는 요청이 리디렉션 URI 누락 또는 유효하지 않은 것 외의 이유로 실패한 경우, 인가 서버는 클라이언트에게 이를 알립니다.
이때, 부록 B에 따라 ‘application/x-www-form-urlencoded’ 형식을 사용하여 다음 매개변수를 리디렉션 URI의 쿼리 컴포넌트에 추가하여 전달합니다.

- error: 
필수 항목(REQUIRED)입니다. 다음 중 하나의 ASCII(US-ASCII) 오류 코드가 사용됩니다.
  - invalid_request:
  
    요청에 필수 매개변수가 누락되었거나, 유효하지 않은 매개변수 값을 포함하고 있거나, 동일한 매개변수를 여러 번 포함하고 있거나, 그 외의 이유로 형식이 올바르지 않은 경우입니다.
  - unauthorized_client:
  
    클라이언트는 이 방법을 사용하여 인가 코드를 요청할 권한이 없습니다.
  - access_denied
  
    리소스 소유자 또는 인가 서버가 요청을 거부했습니다.
  - unsupported_response_type:
  
    인가 서버는 이 방법을 사용하여 인가 코드를 얻는 것을 지원하지 않습니다.
  - invalid_scope:
  
    요청된 범위(scope)가 유효하지 않거나, 알 수 없거나, 형식이 올바르지 않습니다.
  - server_error:
  
    인가 서버에서 예기치 않은 오류가 발생하여 요청을 처리할 수 없습니다.
    (이 오류 코드는 500 Internal Server Error 상태 코드를 HTTP 리디렉션을 통해 클라이언트에게 반환할 수 없기 때문에 필요합니다.)
  - temporarily_unavailable:
  
    인가 서버가 일시적인 과부하 또는 유지보수로 인해 현재 요청을 처리할 수 없습니다.
    (이 오류 코드는 503 Service Unavailable 상태 코드를 HTTP 리디렉션을 통해 클라이언트에게 반환할 수 없기 때문에 필요합니다.)
    error 매개변수의 값에는 지정된 문자 범위(`%x20-21 / %x23-5B / %x5D-7E`) 외의 문자를 포함해서는 안 됩니다 (MUST NOT).
  - error_description:
  
    선택 항목(OPTIONAL)입니다.
    발생한 오류를 이해하는 데 도움이 되는 추가 정보를 제공하는 사람이 읽을 수 있는 ASCII(US-ASCII) 텍스트입니다.
    주로 클라이언트 개발자를 지원하기 위해 사용됩니다.
    error_description 매개변수의 값에는 지정된 문자 범위(`%x20-21 / %x23-5B / %x5D-7E`) 외의 문자를 포함해서는 안 됩니다 (MUST NOT).
  - error_uri:
  
    선택 항목(OPTIONAL)입니다.
    오류에 대한 정보를 제공하는 사람이 읽을 수 있는 웹 페이지를 식별하는 URI입니다.
    이는 클라이언트 개발자에게 오류에 대한 추가 정보를 제공하는 데 사용됩니다.
    error_uri 매개변수의 값은 URI 참조 문법을 따라야 하며 (MUST), 지정된 문자 범위(`%x21 / %x23-5B / %x5D-7E`) 외의 문자를 포함해서는 안 됩니다 (MUST NOT).”

  - state:
  
    클라이언트의 인가 요청에 state 매개변수가 포함된 경우, 필수 항목(REQUIRED)입니다.
    클라이언트로부터 받은 값과 정확히 동일한 값을 반환해야 합니다.

예를 들어, 인가 서버는 다음 HTTP 응답을 전송하여 사용자 에이전트를 리디렉트합니다.

```
 HTTP/1.1 302 Found
   Location: https://client.example.com/cb?error=access_denied&state=xyz
```

#### 4.1.3. 액세스 토큰 요청
클라이언트는 부록 B에 따라 application/x-www-form-urlencoded 형식을 사용하여 다음 매개변수를 포함한 요청을 전송합니다.

이 요청은 HTTP 요청 본문(entity-body)에 UTF-8 문자 인코딩을 사용하여 토큰 엔드포인트로 전송됩니다.

- grant_type:

  필수 항목(REQUIRED)입니다.
  값은 반드시 ‘authorization_code’로 설정해야 합니다 (MUST).
- code:

  필수 항목(REQUIRED)입니다.
  인가 서버로부터 받은 인가 코드입니다.
- redirect_uri: 

  인가 요청([섹션 4.1.1](#411-인가-요청) 참조)에 redirect_uri 매개변수가 포함된 경우, 필수 항목(REQUIRED)입니다.
  이때, 해당 값은 반드시 요청 시 제공된 값과 동일해야 합니다 (MUST).
- client_id: 

  클라이언트가 인가 서버에 대한 인증을 수행하지 않는 경우([섹션 3.2.1](#321-클라이언트-인증) 참조), 필수 항목(REQUIRED)입니다.

클라이언트 유형이 기밀 클라이언트(confidential)인 경우, 또는 클라이언트가 클라이언트 인증 정보를 발급받았거나 다른 인증 요구 사항이 부여된 경우, 클라이언트는 [섹션 3.2.1](#321-클라이언트-인증)에 설명된 대로 인가 서버에 대해 인증해야 합니다 (MUST).

예를 들어, 클라이언트는 TLS를 사용하여 다음 HTTP 요청을 전송합니다.

(아래 요청은 가독성을 위해 추가 줄 바꿈이 포함되었습니다.)

```
POST /token HTTP/1.1
     Host: server.example.com
     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
     Content-Type: application/x-www-form-urlencoded

     grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA
     &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
```

인가 서버는 다음 사항을 수행해야 합니다 (MUST):

- 기밀 클라이언트(confidential clients) 또는 클라이언트 인증 정보를 발급받은(또는 기타 인증 요구 사항이 부여된)모든 클라이언트에 대해 클라이언트 인증을 요구해야 합니다.
- 클라이언트 인증이 포함된 경우, 클라이언트를 인증해야 합니다.
- 인가 코드가 인증된 기밀 클라이언트에게 발급되었는지 확인해야 합니다.
- 만약 클라이언트가 공개 클라이언트(public client)라면, 인가 코드가 요청의 client_id에 발급되었는지 확인해야 합니다.
- 인가 코드가 유효한지 검증해야 합니다.
- 초기 인가 요청([섹션 4.1.1](#411-인가-요청) 참조)에 redirect_uri 매개변수가 포함된 경우, redirect_uri 매개변수가 반드시 존재하는지 확인해야 합니다.
또한, 포함된 경우 해당 값이 요청 시 제공된 값과 동일한지 확인해야 합니다.

#### 4.1.4. 액세스 토큰 응답
액세스 토큰 요청이 유효하고 승인된 경우, 인가 서버는 섹션 5.1에 설명된 대로 액세스 토큰과 선택적 리프레시 토큰을 발급합니다.

요청 클라이언트 인증이 실패했거나 유효하지 않은 경우, 인가 서버는 섹션 5.2에 설명된 대로 오류 응답을 반환합니다.

성공적인 응답 예시:
```
  HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache

     {
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
       "example_parameter":"example_value"
     }
```

### 4.2. 암묵적 승인

암묵적 승인(Implicit Grant) 유형은 액세스 토큰을 얻기 위해 사용됩니다.
(이 방식은 리프레시 토큰 발급을 지원하지 않습니다.)
또한, 특정 리디렉션 URI를 사용하는 것으로 알려진 공개 클라이언트(public clients)에 최적화되어 있습니다.
이러한 클라이언트는 일반적으로 브라우저에서 JavaScript와 같은 스크립팅 언어를 사용하여 구현됩니다.

이 방식은 리디렉션 기반 흐름이므로, 클라이언트는 리소스 소유자의 사용자 에이전트(일반적으로 웹 브라우저)와 상호작용할 수 있어야 합니다.
또한, 인가 서버로부터 리디렉션을 통해 들어오는 요청을 받을 수 있어야 합니다.

인가 코드 승인(Authorization Code Grant) 유형에서는 클라이언트가 인가 요청과 액세스 토큰 요청을 별도로 수행하는 반면, 암묵적 승인(Implicit Grant) 유형에서는 클라이언트가 인가 요청의 결과로 액세스 토큰을 직접 받습니다.

암묵적 승인 유형은 클라이언트 인증을 포함하지 않으며, 리소스 소유자의 존재 및 리디렉션 URI 등록에 의존합니다.

또한, 액세스 토큰이 리디렉션 URI에 인코딩되어 전달되므로, 이 토큰이 리소스 소유자 및 동일한 장치에 있는 다른 애플리케이션에 노출될 가능성이 있습니다.

```mermaid
sequenceDiagram
    participant RO as 리소스 소유자
    participant UA as 사용자 에이전트
    participant AS as 인가 서버
    participant WHCR as 웹 호스팅 클라이언트 리소스
    participant C as 클라이언트

    C->>UA: (A)클라이언트 식별자 & 리디렉션 URI
    UA->>AS: (A)클라이언트 식별자 & 리디렉션 URI
    UA->>AS: (B)사용자 인증 진행
    UA->>RO: (B)사용자 인증 진행
    AS->>UA: (C)프래그먼트에 액세스 토큰이 포함된 리디렉션 URI
    WHCR->>UA: (E)스크립트
    UA->>UA: (F)
    UA->>C: (G)액세스 토큰
```
단계 (A) 및 (B)를 나타내는 선들은 사용자 에이전트를 통과하면서 두 부분으로 나뉩니다.

그림 4: 암묵적 승인 흐름

그림 4에 나타난 흐름은 다음 단계를 포함합니다.

(A) 클라이언트는 리소스 소유자의 사용자 에이전트를 인가 엔드포인트로 이동시킴으로써 흐름을 시작합니다.
클라이언트는 클라이언트 식별자, 요청된 범위, 로컬 상태, 그리고 인가 서버가 액세스를 허용(또는 거부)한 후 사용자 에이전트를 다시 보낼 리디렉션 URI를 포함합니다.

(B) 인가 서버는 사용자 에이전트를 통해 리소스 소유자를 인증합니다.
또한, 리소스 소유자가 클라이언트의 액세스 요청을 승인하는지 또는 거부하는지를 판단합니다.

(C) 리소스 소유자가 액세스를 승인한다고 가정하면, 인가 서버는 이전에 제공된 리디렉션 URI를 사용하여 사용자 에이전트를 클라이언트로 다시 리디렉트합니다.
리디렉션 URI에는 액세스 토큰이 URI 프래그먼트에 포함되어 있습니다.

(D) 사용자 에이전트는 웹 호스팅 클라이언트 리소스에 요청을 보내
리디렉션 지침을 따릅니다. ([RFC2616]에 따라 프래그먼트는 포함되지 않습니다.)
그러나, 사용자 에이전트는 프래그먼트 정보를 로컬에 저장합니다.

(E) 웹 호스팅 클라이언트 리소스는 사용자 에이전트가 저장한 프래그먼트를 포함한 전체 리디렉션 URI에 접근할 수 있으며, 프래그먼트에 포함된 액세스 토큰(및 기타 매개변수)을 추출할 수 있는 웹 페이지(일반적으로 스크립트가 포함된 HTML 문서)를 반환합니다.

(F) 사용자 에이전트는 웹 호스팅 클라이언트 리소스에서 제공한 스크립트를 로컬에서 실행하며, 이 스크립트는 액세스 토큰을 추출합니다.

(G) 사용자 에이전트는 액세스 토큰을 클라이언트에게 전달합니다.

암묵적 승인(Implicit Grant) 사용에 대한 배경 정보는 [섹션 1.3.2](#132-암묵적-승인) 및 [9](#9-네이티브-애플리케이션)를 참조하십시오.
암묵적 승인 사용 시 중요한 보안 고려 사항에 대한 내용은 [섹션 10.3](#103-액세스-토큰) 및 [10.16](#1016-암묵적-승인-흐름에서-액세스-토큰-오용)을 참조하십시오.

#### 4.2.1. 인가 요청
클라이언트는 부록 B에 따라 application/x-www-form-urlencoded 형식을 사용하여 다음 매개변수를 인가 엔드포인트 URI의 쿼리 컴포넌트에 추가하여 요청 URI를 구성합니다.

- response_type: 

  필수 항목(REQUIRED)입니다. 값은 반드시 ‘token’으로 설정해야 합니다 (MUST).
- client_id: 

  필수 항목(REQUIRED)입니다. 클라이언트 식별자는 [섹션 2.2](#22-클라이언트-식별자)에서 설명된 대로 설정해야 합니다.

- redirect_uri: 

  선택 항목(OPTIONAL)입니다. [섹션 3.1.2](#312-리디렉션-엔드포인트)에서 설명된 대로 설정할 수 있습니다.
- scope: 

  선택 항목(OPTIONAL)입니다. 액세스 요청의 범위는 섹션 3.3에서 설명된 대로 설정할 수 있습니다.
- state: 

  권장 항목(RECOMMENDED)입니다. 클라이언트가 요청과 콜백 간의 상태를 유지하는 데 사용하는 불투명한 값입니다. 
  인가 서버는 사용자 에이전트를 클라이언트로 다시 리디렉트할 때 이 값을 포함합니다.
  이 매개변수는 크로스 사이트 요청 위조(CSRF)를 방지하기 위해 사용해야 합니다 (SHOULD).
  자세한 내용은 [섹션 10.12](#1012-크로스-사이트-요청-위조-csrf)에서 설명하고 있습니다.

클라이언트는 HTTP 리디렉션 응답을 사용하거나, 사용자 에이전트를 통해 이용할 수 있는 다른 방법을 사용하여 리소스 소유자를 구성된 URI로 이동시킵니다.

예를 들어, 클라이언트는 사용자 에이전트에게 TLS를 사용하여 다음 HTTP 요청을 수행하도록 지시합니다.
(아래 요청은 가독성을 위해 추가 줄 바꿈이 포함되었습니다.)

```
   GET /authorize?response_type=token&client_id=s6BhdRkqt3&state=xyz
        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
    Host: server.example.com
```

인가 서버는 모든 필수 매개변수가 존재하며 유효한지 확인하기 위해 요청을 검증합니다.

인가 서버는 액세스 토큰을 리디렉트할 리디렉션 URI가 클라이언트에 의해 등록된 리디렉션 URI와 일치하는지 반드시 확인해야 합니다 (MUST).
(이는 [섹션 3.1.2](#312-리디렉션-엔드포인트)에서 설명된 대로 이루어져야 합니다.)

요청이 유효한 경우, 인가 서버는 리소스 소유자를 인증하고 인가 결정을 얻습니다.
이 과정은 리소스 소유자에게 직접 요청하거나, 다른 방법을 통해 승인을 확보하여 진행됩니다.

인가 결정이 확립되었을 때, 인가 서버는 사용자 에이전트를 제공된 클라이언트 리디렉션 URI로 이동시킵니다.
이 과정은 HTTP 리디렉션 응답을 사용하거나, 사용자 에이전트를 통해 이용할 수 있는 다른 방법을 사용하여 진행됩니다.

#### 4.2.2. 액세스 토큰 응답
리소스 소유자가 액세스 요청을 승인하는 경우, 인가 서버는 액세스 토큰을 발급하고 이를 클라이언트에게 전달합니다.
이때, 부록 B에 따라 `‘application/x-www-form-urlencoded’` 형식을 사용하여 다음 매개변수를 리디렉션 URI의 프래그먼트 컴포넌트에 추가합니다.

- access_token: 

  필수 항목(REQUIRED)입니다. 인가 서버가 발급한 액세스 토큰입니다.
- token_type: 

  필수 항목(REQUIRED)입니다. 발급된 토큰의 유형은 [섹션 7.1](#71-액세스-토큰-유형)에서 설명된 대로 설정됩니다. 값은 대소문자를 구분하지 않습니다.

- expires_in: 

  권장 항목(RECOMMENDED)입니다. 액세스 토큰의 수명을 초 단위로 나타냅니다.
  예를 들어, 값이 ‘3600’이면 응답이 생성된 시점으로부터 한 시간 후에 액세스 토큰이 만료됩니다.
  이 값이 생략된 경우, 인가 서버는 다른 방법을 통해 만료 시간을 제공하거나 기본 값을 문서화해야 합니다 (SHOULD).
- scope: 

  선택 항목(OPTIONAL)입니다. 단, 요청된 범위와 동일하지 않은 경우 필수 항목(REQUIRED)입니다.
  액세스 토큰의 범위는 [섹션 3.3](#33-접근-토큰-범위)에서 설명된 대로 설정됩니다.
- state: 

  클라이언트의 인가 요청에 state 매개변수가 포함된 경우, 필수 항목(REQUIRED)입니다.
  클라이언트로부터 받은 값과 정확히 동일한 값을 반환해야 합니다.

인가 서버는 리프레시 토큰을 발급해서는 안 됩니다 (MUST NOT).

예를 들어, 인가 서버는 다음 HTTP 응답을 전송하여 사용자 에이전트를 리디렉트합니다.
(아래 응답은 가독성을 위해 추가 줄 바꿈이 포함되었습니다.)

```
     HTTP/1.1 302 Found
     Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA
               &state=xyz&token_type=example&expires_in=3600
```

개발자는 일부 사용자 에이전트가 HTTP "Location" 응답 헤더 필드에서 프래그먼트 컴포넌트 포함을 지원하지 않는다는 점을 유의해야 합니다 (SHOULD).
이러한 클라이언트는 3xx 리디렉션 응답이 아닌 다른 방법을 사용하여 클라이언트를 리디렉트해야 합니다.
예를 들어, 리디렉션 URI에 연결된 ‘continue’ 버튼을 포함한 HTML 페이지를 반환하는 방식이 사용될 수 있습니다.

클라이언트는 알 수 없는 응답 매개변수를 반드시 무시해야 합니다 (MUST).
액세스 토큰 문자열 크기는 이 명세서에서 정의되지 않았습니다.
클라이언트는 값의 크기에 대한 가정을 피하는 것이 권장됩니다.
인가 서버는 발급하는 값의 크기를 문서화하는 것이 권장됩니다 (SHOULD).

#### 4.2.2.1 오류 응답
요청이 리디렉션 URI가 누락되었거나, 유효하지 않거나, 일치하지 않는 경우, 또는 클라이언트 식별자가 누락되었거나 유효하지 않은 경우, 인가 서버는 리소스 소유자에게 오류를 알려야 합니다 (SHOULD).
또한, 인가 서버는 사용자 에이전트를 잘못된 리디렉션 URI로 자동으로 리디렉트해서는 안 됩니다 (MUST NOT).

리소스 소유자가 액세스 요청을 거부하는 경우, 또는 요청이 리디렉션 URI 누락 또는 유효하지 않은 경우 이외의 이유로 실패하는 경우, 인가 서버는 부록 B에 따라
`‘application/x-www-form-urlencoded’` 형식을 사용하여 다음 매개변수를 리디렉션 URI의 프래그먼트 컴포넌트에 추가하는 방식으로 클라이언트에게 오류를 알립니다.

- error: 
  
  필수 항목(REQUIRED)입니다.
  다음 중 하나의 ASCII(US-ASCII) 오류 코드가 사용됩니다.
- invalid_request:
  
  요청에서 필수 매개변수가 누락되었거나, 유효하지 않은 매개변수 값을 포함하고 있거나, 동일한 매개변수를 여러 번 포함하고 있거나, 형식이 올바르지 않은 경우 발생하는 오류입니다.
- unauthorized_client:
  
  클라이언트가 이 방법을 사용하여 액세스 토큰을 요청할 권한이 없는 경우 발생하는 오류입니다.
- access_denied:

  리소스 소유자 또는 인가 서버가 요청을 거부한 경우 발생하는 오류입니다.
- unsupported_response_type:

  인가 서버가 이 방법을 사용한 액세스 토큰 발급을 지원하지 않는 경우 발생하는 오류입니다.
- invalid_scope:
  
  요청된 범위(scope)가 유효하지 않거나, 알 수 없거나, 형식이 올바르지 않은 경우 발생하는 오류입니다.

- server_error:

  인가 서버에서 예기치 않은 상황이 발생하여 요청을 처리할 수 없는 경우 발생하는 오류입니다.
  (이 오류 코드는 HTTP 리디렉션을 통해 클라이언트에게 500 내부 서버 오류(Internal Server Error)를 반환할 수 없기 때문에 필요합니다.)
- temporarily_unavailable:
  
  인가 서버가 일시적인 과부하 또는 유지보수로 인해 현재 요청을 처리할 수 없는 경우 발생하는 오류입니다.
  (이 오류 코드는 HTTP 리디렉션을 통해 클라이언트에게 503 서비스 불가(Service Unavailable)상태 코드를 반환할 수 없기 때문에 필요합니다.)

error 매개변수의 값에는 문자 집합 `%x20-21 / %x23-5B / %x5D-7E` 이외의 문자를 포함해서는 안 됩니다 (MUST NOT).

- error_description: 

  선택 항목(OPTIONAL)입니다.
  사람이 읽을 수 있는 ASCII(US-ASCII) 텍스트로, 발생한 오류를 클라이언트 개발자가 이해하는 데 도움이 되는 추가 정보를 제공합니다.
  error_description 매개변수의 값에는 문자 집합 `%x20-21 / %x23-5B / %x5D-7E` 이외의 문자를 포함해서는 안 됩니다 (MUST NOT).
- error_uri: 

  선택 항목(OPTIONAL)입니다.
  오류에 대한 정보를 포함하는 사람이 읽을 수 있는 웹 페이지를 식별하는 URI로, 클라이언트 개발자에게 추가 정보를 제공합니다.
  error_uri 매개변수의 값은 URI 참조 구문(URI-reference syntax)을 따라야 하며 (MUST), 문자 집합 `%x21 / %x23-5B / %x5D-7E` 이외의 문자를 포함해서는 안 됩니다 (MUST NOT).
- state: 

  클라이언트의 인가 요청에 state 매개변수가 포함된 경우, 필수 항목(REQUIRED)입니다.
  클라이언트로부터 받은 값과 정확히 동일한 값을 반환해야 합니다.

예를 들어, 인가 서버는 다음 HTTP 응답을 전송하여 사용자 에이전트를 리디렉트합니다.

```
   HTTP/1.1 302 Found
   Location: https://client.example.com/cb#error=access_denied&state=xyz
```

### 4.3 리소스 소유자 비밀번호 자격 증명 승인 방식

이 승인 유형은 리소스 소유자가 클라이언트와 신뢰 관계를 맺고 있는 경우에 적합합니다.
예를 들어, 클라이언트가 기기 운영체제의 일부이거나 높은 권한을 가진 애플리케이션인 경우가 이에 해당합니다.
인가 서버는 이 승인 방식을 활성화할 때 특별히 주의해야 하며, 다른 승인 흐름이 사용 가능한 경우에는 사용하지 않아야 합니다 (SHOULD).

이 승인 유형은 리소스 소유자의 자격 증명(일반적으로 대화형 폼을 통해 사용자 이름과 비밀번호)을 얻을 수 있는 클라이언트에 적합하며,
기존의 HTTP Basic 또는 Digest 인증과 같은 직접 인증 방식을 사용하는 클라이언트를 OAuth로 마이그레이션하기 위해
저장된 자격 증명을 액세스 토큰으로 변환하는 데에도 사용됩니다.

```mermaid
flowchart TD
A[리소스 소유자]
B[클라이언트]
C[인가 서버]

A -->|"(A) 비밀번호 자격 증명 제공"| B
B -->|"(B) 리소스 소유자 비밀번호 자격 증명"| C
C -->|"(C)액세스 토큰 발급 (옵션: 리프레시 토큰 포함)"| B

```

그림 5: 리소스 소유자 비밀번호 자격 증명 흐름

그림 5에 설명된 흐름은 다음 단계를 포함합니다:

(A) 리소스 소유자는 클라이언트에게 사용자 이름과 비밀번호를 제공합니다.

(B) 클라이언트는 리소스 소유자로부터 받은 자격 증명을 포함하여 인가 서버의 토큰 엔드포인트에 액세스 토큰을 요청합니다. 요청 시 클라이언트는 인가 서버에 인증을 수행합니다.

(C) 인가 서버는 클라이언트를 인증하고 리소스 소유자 자격 증명을 검증하며, 유효한 경우 액세스 토큰을 발급합니다.

### 4.3.1 인가 요청 및 응답

클라이언트가 리소스 소유자 자격 증명을 얻는 방법은 이 명세의 범위를 벗어납니다. 클라이언트는 액세스 토큰을 얻은 후 자격 증명을 폐기해야 합니다(MUST).

### 4.3.2 액세스 토큰 요청

클라이언트는 HTTP 요청 본문에 다음 매개변수를 "application/x-www-form-urlencoded" 형식으로 추가하여 토큰 엔드포인트에 요청을 보냅니다. (UTF-8 문자 인코딩 사용):

- `grant_type`: 필수(REQUIRED). 값은 "password"로 설정해야 합니다.
- `username`: 필수(REQUIRED). 리소스 소유자의 사용자 이름.
- `password`: 필수(REQUIRED). 리소스 소유자의 비밀번호.
- `scope`: 선택적(OPTIONAL). 접근 요청의 범위.

클라이언트 유형이 신뢰할 수 있는 클라이언트이거나 클라이언트 자격 증명이 발급된 경우, 클라이언트는 인가 서버에 인증해야 합니다(MUST).

예시 HTTP 요청:

```http
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=password&username=johndoe&password=A3ddj3w
```

인가 서버는 다음을 수행해야 합니다:

- 신뢰할 수 있는 클라이언트 또는 클라이언트 자격 증명이 발급된 모든 클라이언트에 대해 클라이언트 인증 요구(MUST).
- 클라이언트 인증이 포함된 경우 클라이언트를 인증(MUST).
- 기존 비밀번호 검증 알고리즘을 사용하여 리소스 소유자 비밀번호 자격 증명을 검증(MUST).

이 액세스 토큰 요청은 리소스 소유자의 비밀번호를 사용하므로, 인가 서버는 무차별 공격으로부터 엔드포인트를 보호해야 합니다(MUST).

### 4.3.3 액세스 토큰 응답

액세스 토큰 요청이 유효하고 인가된 경우, 인가 서버는 액세스 토큰과 선택적 리프레시 토큰을 발급합니다. 요청이 클라이언트 인증에 실패하거나 유효하지 않은 경우, 인가 서버는 오류 응답을 반환합니다.

성공적인 응답 예시:

```json
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  "token_type":"example",
  "expires_in":3600,
  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
  "example_parameter":"example_value"
}
```

### 4.4 클라이언트 자격 증명 승인 방식

클라이언트는 보호된 리소스에 대한 접근을 요청할 때 클라이언트 자격 증명(또는 다른 지원되는 인증 수단)만을 사용하여 액세스 토큰을 요청할 수 있습니다.

클라이언트 자격 증명 승인 방식은 반드시 신뢰할 수 있는 클라이언트에 의해서만 사용되어야 합니다.

```mermaid
flowchart LR
A[클라이언트]
B[인가 서버]

  A-->|"(A) 클라이언트 인증 및 액세스 토큰 요청"|B
  B-->|"(B) 액세스 토큰 발급"|A
```

그림 6: 클라이언트 자격 증명 흐름

그림 6에 설명된 흐름은 다음 단계를 포함합니다:

(A) 클라이언트는 인가 서버에 인증하고 토큰 엔드포인트에서 액세스 토큰을 요청합니다.

(B) 인가 서버는 클라이언트를 인증하고, 유효한 경우 액세스 토큰을 발급합니다.

### 4.4.1 인가 요청 및 응답

클라이언트 인증이 인가 승인으로 사용되므로 추가적인 인가 요청은 필요하지 않습니다.

### 4.4.2 액세스 토큰 요청

클라이언트는 HTTP 요청 본문에 다음 매개변수를 "application/x-www-form-urlencoded" 형식으로 추가하여 토큰 엔드포인트에 요청을 보냅니다. (UTF-8 문자 인코딩 사용):

- `grant_type`: 필수(REQUIRED). 값은 "client_credentials"로 설정해야 합니다.
- `scope`: 선택적(OPTIONAL). 접근 요청의 범위.

클라이언트는 인가 서버에 인증해야 합니다(MUST).

예시 HTTP 요청:

```http
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
```

인가 서버는 클라이언트를 인증해야 합니다(MUST).

### 4.4.3 액세스 토큰 응답

액세스 토큰 요청이 유효하고 인가된 경우, 인가 서버는 액세스 토큰을 발급합니다. 리프레시 토큰은 포함되지 않아야 합니다(SHOULD NOT). 요청이 클라이언트 인증에 실패하거나 유효하지 않은 경우, 인가 서버는 오류 응답을 반환합니다.

성공적인 응답 예시:

```json
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  "token_type":"example",
  "expires_in":3600,
  "example_parameter":"example_value"
}
```

### 4.5 확장 승인

클라이언트는 토큰 엔드포인트의 "grant_type" 매개변수 값으로 절대 URI(인가 서버에 의해 정의됨)를 지정하고 필요한 추가 매개변수를 추가하여 확장 승인 유형을 사용합니다.

예를 들어, [OAuth-SAML2]에 의해 정의된 SAML 2.0 어설션 승인 유형을 사용하여 액세스 토큰을 요청하려면, 클라이언트는 다음과 같은 HTTP 요청을 TLS를 사용하여 보낼 수 있습니다:

```http
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-bearer&assertion=PEFzc2VydGlvbiBJc3N1ZUluc3RhbnQ9IjIwMTEtMDU[...생략...]aG5TdGF0ZW1lbnQ-PC9Bc3NlcnRpb24-

```

액세스 토큰 요청이 유효하고 승인된 경우,
인가 서버는 [5.1.](#51-성공-응답)에 설명된 대로 액세스 토큰과 선택적 리프레시
토큰을 발급합니다. 요청이 클라이언트 인증에 실패하거나 유효하지 않은 경우,
인가 서버는 [5.2.](#52-오류-응답)에 설명된 대로 오류 응답을 반환합니다.

## 9. 네이티브 애플리케이션

네이티브 애플리케이션은 리소스 소유자가 사용하는 기기에 설치 및 실행되는 클라이언트입니다(예: 데스크톱 애플리케이션, 네이티브 모바일 애플리케이션). 네이티브 애플리케이션은 보안, 플랫폼 기능, 그리고 전반적인 최종 사용자 경험과 관련하여 특별한 고려가 필요합니다.

인가 엔드포인트는 클라이언트와 리소스 소유자의 유저 에이전트 간의 상호작용을 요구합니다. 네이티브 애플리케이션은 외부 유저 에이전트를 호출하거나 애플리케이션 내에 유저 에이전트를 포함할 수 있습니다. 예를 들어:

- 외부 유저 에이전트 - 네이티브 애플리케이션은 운영 체제에 등록된 스킴을 사용하여 클라이언트를 핸들러로 호출하는 리디렉션 URI를 통해 인가 서버의 응답을 캡처하거나, 자격 증명을 수동으로 복사하여 붙여넣기, 로컬 웹 서버 실행, 유저 에이전트 확장 설치, 또는 클라이언트가 제어하는 서버 호스팅 리소스를 식별하는 리디렉션 URI를 제공하여 네이티브 애플리케이션에 응답을 제공할 수 있습니다.

- 내장된 유저 에이전트 - 네이티브 애플리케이션은 리소스 로드 중에 발생하는 상태 변화를 모니터링하거나 유저 에이전트의 쿠키 저장소에 접근하여 내장된 유저 에이전트와 직접 통신하여 응답을 얻습니다.

외부 또는 내장된 유저 에이전트 중에서 선택할 때, 개발자는 다음을 고려해야 합니다:

- 외부 유저 에이전트는 리소스 소유자가 이미 인가 서버와 활성 세션을 가지고 있을 수 있어 재인증이 필요 없으므로 완료율을 향상시킬 수 있습니다. 이는 익숙한 최종 사용자 경험과 기능을 제공합니다. 리소스 소유자는 또한 인증을 돕기 위해 유저 에이전트 기능이나 확장(예: 비밀번호 관리자, 2단계 인증 장치 리더기)에 의존할 수 있습니다.

- 내장된 유저 에이전트는 컨텍스트 전환과 새 창을 열 필요가 없어 사용성을 향상시킬 수 있습니다.

- 내장된 유저 에이전트는 보안 문제를 제기합니다. 왜냐하면 리소스 소유자가 대부분의 외부 유저 에이전트에서 발견되는 시각적 보호 없이 식별되지 않은 창에서 인증을 수행하기 때문입니다. 내장된 유저 에이전트는 최종 사용자에게 식별되지 않은 인증 요청을 신뢰하도록 교육하여 피싱 공격을 쉽게 실행할 수 있게 만듭니다.

암묵적 승인 방식과 인가 코드 승인 방식 중에서 선택할 때, 다음을 고려해야 합니다:

- 인가 코드 승인 방식을 사용하는 네이티브 애플리케이션은 클라이언트 자격 증명을 기밀로 유지할 수 없기 때문에 클라이언트 자격 증명을 사용하지 않고 이를 수행해야 합니다(SHOULD).

- 암묵적 승인 방식 흐름을 사용할 때, 리프레시 토큰이 반환되지 않으므로 액세스 토큰이 만료되면 인가 프로세스를 반복해야 합니다.

## 5. 액세스 토큰 발급

액세스 토큰 요청이 유효하고 인가되었다면, 인가 서버는 액세스 토큰과 리프레시 토큰을 발급합니다. (5.1절 참고)
이때 리프레시 토큰의 발급은 선택적입니다. 만약 해당 요청으로부터 클라이언트 인증이 실패했다면 (혹은 요청이 유효하지 않다면) 인가 서버는 5.2절에 설명된 것처럼 에러 응답을 반환합니다.

### 5.1 성공 응답
인가 서버는 액세스 토큰과 (필요 시) 리프레시 토큰을 발급하며 HTTP 응답 코드 200의 응답 본문을 구성합니다. 이때 아래 파라미터를 포함합니다.

* `access_token`
    * **필수.** 인가 서버가 발급한 액세스 토큰
* `token_type`
    * **필수.** 발급된 토큰의 타입 (7.1절 참고)
* `expires_in`
    * **권장.** 초 단위로 표현한 액세스 토큰의 수명. 예를 들어, `3600` 이라는 값은 액세스 토큰이 응답이 생성된 시점으로부터 1시간 이후에 만료될 것임을 의미합니다. 만약 이 파라미터가 생략된다면, 인가 서버는 반드시 다른 수단이나 문서를 통해 기본값을 제공해야 합니다. (SHOULD),.
* `refresh_token`
    * **선택.** 동일한 인가 방식(authorization grant) 을 사용하여 새로운 액세스 토큰을 취득하는 데에 쓰입니다. (6절 참고)
* `scope`
    * **선택.** 클라이언트에서 요청한 scope 와 동일하다면 제외해도 되나, 그렇지 않다면 필수로 포함해야 합니다. 액세스 토큰의 범위는 3.3절 참고.

위 파라미터들은 [RFC4267](https://datatracker.ietf.org/doc/html/rfc4627) 에 따라 `application/json` 미디어 타입의 HTTP 응답 본문에 포함됩니다. 파라미터들은 최상위 구조 수준에서 JavaScript Object Notation (JSON) 구조로 직렬화됩니다. 파라미터 이름과 문자열 값은 JSON 문자열로, 숫자 값은 JSON 숫자로 포함됩니다. 파라미터의 순서는 중요하지 않으며 달라질 수 있습니다. 인가 서버는 토큰, 자격 증명 또는 기타 민감한 정보를 포함하는 응답에 대해 반드시 HTTP `Cache-Control` 응답 헤더 필드 [RFC2616](https://datatracker.ietf.org/doc/html/rfc2616) 를 `no-store` 값으로 포함해야 하며, `Pragma` 응답 헤더 필드 [RFC2616](https://datatracker.ietf.org/doc/html/rfc2616) 를 `no-cache` 값으로 포함해야 합니다.

예를 들어 아래와 같습니다:
```http
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    "access_token":"2YotnFZFEjr1zCsicMWpAA",
    "token_type":"example",
    "expires_in":3600,
    "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
    "example_parameter":"example_value"
}
```

클라이언트는 응답 본문 내 식별할 수 없는 값 이름들은 반드시 무시해야 합니다 (MUST).
토큰이나 인가 서버로부터 받은 다른 값들의 크기는 정의되지 않으므로 클라이언트는 이에 대한 가정을 해서는 안 됩니다. 인가 서버는 발급하는 모든 값에 대해 그 크기를 문서화해야 합니다 (SHOULD).

### 5.2 오류 응답
에러 상황에서 인가 서버는 HTTP 응답 코드 400의 응답하며 (다른 상태 코드를 사용한다고 명시하지 않는 이상), 아래의 파라미터들을 포함합니다. 

* `error`
    * **필수.** 아래 ASCII 코드 중 한 개.
        * `invalid_request` 
            * 요청이 필수 파라미터를 누락했거나, 지원하지 않은 파라미터 값을 포함하거나 (인가 방식 제외하고), 파라미터를 중복하여 포함하거나, 2개 이상의 자격 증명 정보를 포함하거나, 클라이언트를 인증하는 방식이 여러개 사용되었거나, 그 외 잘못된 형태를 띄는 경우.
        * `invalid_client`
            * 클라이언트 인증 실패 (예: 식별할 수 없는 클라이언트, 누락된 클라이언트 인증 정보, 지원하지 않은 인증 방식). 인가 서버는 어떤 인증 방식이 지원되는지 암시하기 위해 401 상태코드(Unauthorized) 를 사용할 수 있다 (MAY). 클라이언트가 `Authorization` 요청 헤더를 이용해 인증을 시도하는 경우, 인가 서버는 반드시 401 상태코드로 응답해야하며 (MUST), `WWW-Authenticate` 응답 헤더에 클라이언트가 사용한 인증 방식을 포함해야 한다.
        * `invalid_grant`
            * 제공된 인가 방식 (예: 인가 코드, 리소스 소유자 자격증명) 또는 리프레시 토큰이 유효하지 않거나, 만료되었거나, 철회되었거나, 인가 요청에 사용된 리디렉션 URI와 일치하지 않거나, 다른 클라이언트에게 발급된 경우.
        * `unauthorized_client`
            * 인증된 클라이언트가 제공된 인가 방식을 방식을 사용할 권한이 없는 경우.
        * `unsupported_grant_type`
            * 제공된 인가 방식이 인가 서버에 의해 지원되지 않는 경우.
        * `invalid_scope`
            * 요청된 범위가 유효하지 않거나, 식별할 수 없거나, 형태가 잘못되었거나, 혹은 리소스 소유자에 의해 승인된 범위를 초과하는 경우.
    * `error` 파라미터의 값은 `%x20-21 / %x23-5B / %x5D-7E` 집합의 범위를 벗어나는 문자열을 포함해서는 안 됩니다. (MUST NOT).
* `error_description`
    * **선택.** 발생한 오류를 이해하는 데 도움이 되는 추가 정보를 제공하는, 사람이 읽을 수 있는 ASCII 텍스트입니다. `error_description` 파라미터의 값은 `%x20-21 / %x23-5B / %x5D-7E` 집합의 범위를 벗어나는 문자를 포함해서는 안 됩니다 (MUST NOT). 
* `error_uri`
    * **선택.** 오류에 대한 정보를 제공하는, 사람이 읽을 수 있는 형채의 웹 페이지를 식별하는 URI입니다. 클라이언트 개발자에게 오류에 대한 추가 정보를 제공하는 데 사용됩니다. `error_uri` 파라미터의 값은 URI 참조 구문을 준수해야 하며, 따라서 `%x21 / %x23-5B / %x5D-7E` 집합의 범위를 벗어나는 문자를 포함해서는 안 됩니다 (MUST NOT).

위 파라미터들은 [RFC4267](https://datatracker.ietf.org/doc/html/rfc4627) 에 따라 `application/json` 미디어 타입의 HTTP 응답 본문에 포함됩니다. 파라미터들은 최상위 구조 수준에서 JavaScript Object Notation (JSON) 구조로 직렬화됩니다. 파라미터 이름과 문자열 값은 JSON 문자열로, 숫자 값은 JSON 숫자로 포함됩니다. 파라미터의 순서는 중요하지 않으며 달라질 수 있습니다.

예를 들어 아래와 같습니다:
```http
HTTP/1.1 400 Bad Request
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    "error":"invalid_request"
}
```

## 6. 액세스 토큰 갱신
인가 서버가 클라이언트에게 리프레시 토큰을 발급했다면, 클라이언트는 HTTP 요청 본문에 UTF-8 문자 인코딩을 사용하여 `application/x-www-form-urlencoded` 형식으로 다음 파라미터들을 추가하여 토큰 엔드포인트에 리프레시 요청을 합니다 (부록 B 참조):
* `grant_type`
    * **필수.** 값은 반드시 `"refresh_token"` 으로 설정되어야 합니다 (MUST).
* `refresh_token`
    * **필수.** 클라이언트에게 발급한 리프레시 토큰.
* `scope`
    * **선택.** 접근 요청의 범위. (3.3절 참고) 요청된 범위는 리소스 소유자가 원래 부여한 범위를 초과해서는 안 되며 (MUST NOT), 생략된 경우 리소스 소유자가 원래 부여한 범위와 동일하게 간주됩니다.

추가적인 액세스 토큰을 요청하기 위해 사용되는 리프레시 토큰은 보편적으로 수명이 긴 자격 증명이기 때문에, 리프레시 토큰은 발급 대상인 클라이언트에 종속됩니다. 신뢰할 수 있는 클라이언트이거나 클라이언트 자격 증명을 발급받은 경우 (또는 다른 인증 요구사항이 부여된 경우), 클라이언트는 3.2.1절에 설명된대로 인가 서버에 인증을 해야 합니다 (MUST).

예를 들어, 클라이언트가 전송 계층 보안을 사용하여 아래와 같은 HTTP 요청을 보낸다고 한다면:
```http
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
```

인가 서버는 반드시 아래의 것들을 해야 합니다. (MUST) :
* 신뢰할 수 있는 클라이언트 또는 클라이언트 자격 증명을 발급받은 클라이언트(또는 다른 인증 요구사항이 있는 클라이언트)에게 클라이언트 인증을 요구해야 하며,
* 클라이언트 인증이 포함된 경우 클라이언트를 인증하고 리프레시 토큰이 인증된 클라이언트에게 발급되었는지 확인해야 하며,
* 리프레시 토큰을 검증해야 합니다.

인가 서버는 리프레시 토큰이 유효하고 인증된 클라이언트에게 발급되었는지 확인한 후, 
5.1절에 설명된대로 액세스 토큰을 발급합니다. 요청이 검증되지 않거나 유효하지 않은 경우, 
인가 서버는 5.2절에 설명된대로 에러 응답을 반환해야 합니다.

인가 서버는 새로운 리프레시 토큰을 발급할 수 있으며 (MAY), 이 경우에 클라이언트는 기존의 리프레시 토큰을 반드시 폐기하고
새로운 리프레시 토큰으로 대체하여 사용해야 합니다 (MUST). 
인가 서버는 클라이언트에게 새로운 리프레시 토큰을 발급한 후에 기존의 리프레시 토큰의 권한을 철회할 수 있습니다 (MAY).
새로운 리프레시 토큰이 발급되었다면, 해당 리프레시 토큰의 범위는 클라이언트가 요청에 포함한 기존 리프레시 토큰의 범위와 동일해야 합니다.

## 7. 보호된 리소스 접근
클라이언트는 리소스 서버에 액세스 토큰을 제시함으로써 보호된 리소스에 접근합니다. 
리소스 서버는 반드시 액세스 토큰을 검증해야 하며 (MUST), 토큰이 만료되지 않았는지, 
그 범위가 요청한 리소스에 접근하기에 충분한지 확인해야 합니다.
리소스 서버가 액세스 토큰을 검증하기 위해 사용하는 방식은 (에러 응답을 구성하는 방식 역시 마찬가지)
이 명세를 벗어나나, 보편적으로 리소스 서버와 인가 서버 간의 상호작용이나 협응을 포함합니다.

클라이언트가 액세스 토큰을 사용하여 리소스 서버에 인증하는 방법은 인가 서버에서 발급한 액세스 토큰의 유형에 따라 다릅니다. 
일반적으로, 이는 [RFC6750](https://datatracker.ietf.org/doc/html/rfc6750) 과 같은 액세스 토큰 유형의 명세서에 정의된 인증 방식을 사용하여 HTTP `Authorization` 요청 헤더 필드 ([RFC2617](https://datatracker.ietf.org/doc/html/rfc2617) 참조)를 사용하는 것을 포함합니다.

### 7.1 액세스 토큰 유형
액세스 토큰의 유형은 클라이언트가 보호된 리소스 요청을 성공적으로 수행하는 데 필요한 정보(유형별 속성 포함)를 제공합니다. 
클라이언트는 토큰 유형을 이해하지 못하는 경우 액세스 토큰을 사용해서는 안 됩니다 (MUST NOT).

예를 들어, [RFC6750](https://datatracker.ietf.org/doc/html/rfc6750) 에 정의된 `bearer` 토큰 타입은 단순히 액세스 토큰 문자열을 요청에 포함하는 방식으로 사용됩니다.
```http
GET /resource/1 HTTP/1.1
Host: example.com
Authorization: Bearer mF_9.B5f-4.1JqM
```

반면에 [OAuth-Http-MAC](https://datatracker.ietf.org/doc/html/rfc6749#ref-OAuth-HTTP-MAC) 에 정의된 `mac` 토큰 타입은 
액세스 토큰과 함께 메시지 인증 코드 (MAC) 키를 발급하여 HTTP 요청의 특정 구성 요소에 서명하는 데 사용됩니다.
```http
GET /resource/1 HTTP/1.1
Host: example.com
Authorization: MAC id="h480djs93hd8",
                nonce="274312:dj83hs9s",
                mac="kDZvddkndxvhGRXZhvuDjEWhGeE="
```
위 예시들은 단지 설명을 위한 목적으로 제공된 것입니다. 개발자들은 사용 전에 [RFC6750] 및 [OAuth-HTTP-MAC] 명세서를 참조하는 것이 좋습니다.

각 액세스 토큰 유형 정의는 `access_token` 응답 파라미터와 함께 클라이언트에게 전송되는 추가 속성들(있는 경우)을 명시합니다. 
또한 보호된 리소스 요청을 할 때 해당 액세스 토큰을 포함하기 위해 사용되는 HTTP 인증 방법도 정의합니다.

### 7.2 오류 응답

리소스 접근 요청이 실패했다면, 리소스 서버는 반드시 클라이언트에게 에러를 응답해야 합니다 (SHOULD).
이러한 에러 응답의 세부 사항은 이 명세의 범위를 벗어나지만, 본 문서는 OAuth 토큰 인증 방식 간에 공유되는 에러 값을 위한 공통 레지스트리(registry)를 11.4절에 정의합니다.

OAuth 토큰 인증을 위해 설계된 새로운 인증 방식은 클라이언트에게 에러 상태 코드를 제공하는 메커니즘을 정의해야 합니다 (SHOULD). 
허용되는 에러 값들은 이 명세서에 의해 설정된 에러 레지스트리에 등록되어야 합니다.

이러한 방식은 유효한 에러 코드의 집합을 등록된 값의 하위 집합으로 제한할 수 있습니다 (MAY). 
에러 코드가 명시적인 파라미터를 사용하여 반환되는 경우, 파라미터 이름은 `error` 이어야 합니다 (SHOULD).

설계의 주목적이 OAuth 토큰 인증을 위한 것이 아니나 OAuth 토큰 인증에 사용할 수 있는 다른 방식들도 
동일한 방식으로 에러 값을 레지스트리에 바인딩할 수 있습니다 (MAY).

새로운 인증 방식은 이 명세서에서 사용되는 방식과 유사하게 에러 정보를 반환하기 위해 `error_description` 및 `error_uri` 파라미터의 사용을 지정할 수 있습니다 (MAY).

## 8. 확장성

### 8.1 액세스 토큰 유형 정의

액세스 토큰 유형은 아래 두가지 방식 중 하나로 정의될 수 있습니다.
1. 11.1절에 설명된 절차에 따라 액세스 토큰 타입 레지스트리에 등록
2. 그 이름으로 고유한 절대 URI를 사용

URI 이름을 사용하는 유형은 특정 벤더에만 국한되어 구현되고 일반적으로는 적용되지 않아야 합니다. (SHOULD). 
이러한 구현은 해당 토큰 유형이 사용되는 리소스 서버의 구현 세부 사항에 의존합니다.

그 외 모든 타입은 반드시 등록되어야 합니다 (MUST). 
타입 이름은 type-name ABNF를 준수해야 합니다 (MUST). 
타입 정의에 새로운 HTTP 인증 방식이 포함되는 경우, 타입 이름은 HTTP 인증 방식 이름과 동일해야 합니다 (SHOULD) ([RFC2617](https://datatracker.ietf.org/doc/html/rfc2617) 참조). 
`example` 토큰 타입은 예제에서 사용하기 위해 예약되어 있습니다.

```ABNF
type-name  = 1*name-char
name-char  = "-" / "." / "_" / DIGIT / ALPHA
```

### 8.2 새로운 엔드포인트 매개변수 정의

인가 엔드포인트 또는 토큰 엔드포인트에서 사용할 새로운 요청 또는 응답 파라미터는 11.2절의 절차에 따라 
OAuth 파라미터 레지스트리에 정의되고 등록됩니다.

파라미터 이름은 param-name ABNF를 준수해야 하며, 파라미터 값의 구문은 잘 정의되어야 합니다 (예: ABNF 사용 또는 기존 파라미터 구문에 대한 참조).
```ABNF
param-name  = 1*name-char
name-char   = "-" / "." / "_" / DIGIT / ALPHA
```

특정 벤더에만 국한되고 등록되지 않은 파라미터의 확장은 일반적으로 적용되지 않으며 사용되는 인가 서버의 구현 세부 사항에 의존합니다.
이러한 확장의 경우, 다른 등록된 값들과 충돌하지 않도록 벤더별 접두사를 사용해야 합니다 (SHOULD). 
예를 들어, 'companyname_'으로 시작하는 방식입니다.

### 8.3 새로운 인가 승인 유형 정의

새로운 인가 승인 유형은 `grant_type` 파라미터와 함께 사용할 고유한 절대 URI를 할당하여 정의할 수 있습니다. (예: https://example.com/oauth/grant-type/custom)
확장 인가 유형이 추가적인 토큰 엔드포인트 파라미터를 필요로 하는 경우, 해당 파라미터들은 11.2절에 설명된 대로 OAuth 파라미터 레지스트리에 등록되어야 합니다 (MUST).

### 8.4 새로운 인가 엔드포인트 응답 유형 정의

인가 엔드포인트에서 사용할 새로운 응답 유형은 11.3절의 절차에 따라 인가 엔드포인트 응답 타입 레지스트리에 정의되고 등록됩니다. 
응답 유형 이름은 response-type ABNF를 준수해야 합니다.
```ABNF
response-type  = response-name *( SP response-name )
response-name  = 1*response-char
response-char  = "_" / DIGIT / ALPHA
```

응답 유형에 하나 이상의 공백 문자(%x20)가 포함된 경우, 이는 값의 순서가 중요하지 않은 공백으로 구분된 값 목록으로 식별 및 비교됩니다. 
동일한 값 집합 내에서 하나의 값 순서만 등록할 수 있습니다.

예를 들어, "token code" 응답 유형은 이 명세서에서 정의되지 않았으나 "token code" 라는 확장 응답 유형을 정의하고 등록할 수 있습니다. 
이 경우, 동일한 조합인 "code token"로 새로운 확장 응답 유형을 등록할 수는 없으며, 두 값 모두 동일한 응답 유형을 나타내는 데 사용됩니다.

### 8.5 추가 오류 코드 정의

확장된 프로토콜(즉, 액세스 토큰 유, 추가 파라미터, 또는 추가적인 승인 유형)이 
인가 코드 승인 에러 응답(4.1.2.1절), 암시적 승인 에러 응답(4.2.2.1절), 토큰 에러 응답(5.2절), 또는 리소스 접근 에러 응답(7.2절)에 사용될 추가적인 에러 코드를 필요로 하는 경우, 
이에 따른 에러 코드를 정의할 수 있습니다 (MAY).

추가 에러 코드가 등록된 액세스 토큰 유형, 등록된 엔드포인트 파라미터, 또는 확장 인가 유형과 함께 사용되는 경우 
11.4절에 따라 반드시 레지스트리에 등록되어야 합니다 (MUST).
등록되지 않은 확장 요소와 함께 사용되는 에러 코드는 등록될 수 있습니다 (MAY).

에러 코드는 error ABNF를 준수해야 하며, 가능하면 식별 이름으로 접두어를 붙여야 합니다 (SHOULD). 
예를 들어, 확장 파라미터 "example"에 잘못된 값이 설정된 경우를 식별하는 에러는 "example_invalid"로 명명되어야 합니다 (SHOULD).
```ABNF
error      = 1*error-char
error-char = %x20-21 / %x23-5B / %x5D-7E
```
